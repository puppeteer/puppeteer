// This file is generated by /doclint/generate_types/index.js
import { ChildProcess } from 'child_process';
import { EventEmitter } from 'events';
/**
 * Can be converted to JSON
 */
interface Serializable {}
interface ConnectionTransport {}


/**
 * This methods attaches Puppeteer to an existing Chromium instance.
 * @param options 
 */
export function connect(options: ConnectOptions) : Promise<Browser>;

/**
 * @param options 
 */
export function createBrowserFetcher(options?: CreateBrowserFetcherOptions) : BrowserFetcher;

/**
 * The default flags that Chromium will be launched with.
 * @param options Set of configurable options to set on the browser. Can have the following fields:
 */
export function defaultArgs(options?: DefaultArgsOptions) : Array<string>;

/**
 * @returns A path where Puppeteer expects to find bundled Chromium. Chromium might not exist there if the download was skipped with `PUPPETEER_SKIP_CHROMIUM_DOWNLOAD`.
 */
export function executablePath() : string;

/**
 * You can use `ignoreDefaultArgs` to filter out `--mute-audio` from default arguments:
 * ```js
 * const browser = await puppeteer.launch({
 *   ignoreDefaultArgs: ['--mute-audio']
 * });
 * ```
 * 
 * **NOTE** Puppeteer can also be used to control the Chrome browser, but it works best with the version of Chromium it is bundled with. There is no guarantee it will work with any other version. Use `executablePath` option with extreme caution.
 * If Google Chrome (rather than Chromium) is preferred, a Chrome Canary or Dev Channel build is suggested.
 * In puppeteer.launch([options]) above, any mention of Chromium also applies to Chrome.
 * See `this article` for a description of the differences between Chromium and Chrome. `This article` describes some differences for Linux users.
 * @param options Set of configurable options to set on the browser. Can have the following fields:
 * @returns Promise which resolves to browser instance.
 */
export function launch(options?: LaunchOptions) : Promise<Browser>;

/**
 * BrowserFetcher can download and manage different versions of Chromium.
 * BrowserFetcher operates on revision strings that specify a precise version of Chromium, e.g. `"533271"`. Revision strings can be obtained from omahaproxy.appspot.com.
 * An example of using BrowserFetcher to download a specific version of Chromium and running
 * Puppeteer against it:
 * ```js
 * const browserFetcher = puppeteer.createBrowserFetcher();
 * const revisionInfo = await browserFetcher.download('533271');
 * const browser = await puppeteer.launch({executablePath: revisionInfo.executablePath})
 * ```
 * 
 * **NOTE** BrowserFetcher is not designed to work concurrently with other
 * instances of BrowserFetcher that share the same downloads directory.
 */
export interface BrowserFetcher {
  /**
   * The method initiates a HEAD request to check if the revision is available.
   * @param revision a revision to check availability.
   * @returns returns `true` if the revision could be downloaded from the host.
   */
  canDownload(revision: string): Promise<boolean>;

  /**
   * The method initiates a GET request to download the revision from the host.
   * @param revision a revision to download.
   * @param progressCallback A function that will be called with two arguments:
   * @returns Resolves with revision information when the revision is downloaded and extracted
   */
  download(revision: string, progressCallback?: (downloadedBytes : number, totalBytes : number) => void): Promise<BrowserFetcherDownload>;

  /**
   * @returns A list of all revisions available locally on disk.
   */
  localRevisions(): Promise<Array<string>>;

  /**
   * @returns One of `mac`, `linux`, `win32` or `win64`.
   */
  platform(): string;

  /**
   * @param revision a revision to remove. The method will throw if the revision has not been downloaded.
   * @returns Resolves when the revision has been removed.
   */
  remove(revision: string): Promise<void>;

  /**
   * @param revision a revision to get info for.
   */
  revisionInfo(revision: string): BrowserFetcherRevisionInfo;
}

/**
 * A Browser is created when Puppeteer connects to a Chromium instance, either through `puppeteer.launch` or `puppeteer.connect`.
 * An example of using a Browser to create a Page:
 * ```js
 * const puppeteer = require('puppeteer');
 * 
 * puppeteer.launch().then(async browser => {
 *   const page = await browser.newPage();
 *   await page.goto('https://example.com');
 *   await browser.close();
 * });
 * ```
 * An example of disconnecting from and reconnecting to a Browser:
 * ```js
 * const puppeteer = require('puppeteer');
 * 
 * puppeteer.launch().then(async browser => {
 *   // Store the endpoint to be able to reconnect to Chromium
 *   const browserWSEndpoint = browser.wsEndpoint();
 *   // Disconnect puppeteer from Chromium
 *   browser.disconnect();
 * 
 *   // Use the endpoint to reestablish a connection
 *   const browser2 = await puppeteer.connect({browserWSEndpoint});
 *   // Close Chromium
 *   await browser2.close();
 * });
 * ```
 */
export interface Browser extends EventEmitter {
  on(event: 'disconnected', listener: (arg0 : void) => void): this;

  /**
   * Emitted when the url of a target changes.
   * 
   * **NOTE** This includes target changes in incognito browser contexts.
   */
  on(event: 'targetchanged', listener: (arg0 : Target) => void): this;

  /**
   * Emitted when a target is created, for example when a new page is opened by `window.open` or `browser.newPage`.
   * 
   * **NOTE** This includes target creations in incognito browser contexts.
   */
  on(event: 'targetcreated', listener: (arg0 : Target) => void): this;

  /**
   * Emitted when a target is destroyed, for example when a page is closed.
   * 
   * **NOTE** This includes target destructions in incognito browser contexts.
   */
  on(event: 'targetdestroyed', listener: (arg0 : Target) => void): this;

  once(event: 'disconnected', listener: (arg0 : void) => void): this;

  /**
   * Emitted when the url of a target changes.
   * 
   * **NOTE** This includes target changes in incognito browser contexts.
   */
  once(event: 'targetchanged', listener: (arg0 : Target) => void): this;

  /**
   * Emitted when a target is created, for example when a new page is opened by `window.open` or `browser.newPage`.
   * 
   * **NOTE** This includes target creations in incognito browser contexts.
   */
  once(event: 'targetcreated', listener: (arg0 : Target) => void): this;

  /**
   * Emitted when a target is destroyed, for example when a page is closed.
   * 
   * **NOTE** This includes target destructions in incognito browser contexts.
   */
  once(event: 'targetdestroyed', listener: (arg0 : Target) => void): this;

  addListener(event: 'disconnected', listener: (arg0 : void) => void): this;

  /**
   * Emitted when the url of a target changes.
   * 
   * **NOTE** This includes target changes in incognito browser contexts.
   */
  addListener(event: 'targetchanged', listener: (arg0 : Target) => void): this;

  /**
   * Emitted when a target is created, for example when a new page is opened by `window.open` or `browser.newPage`.
   * 
   * **NOTE** This includes target creations in incognito browser contexts.
   */
  addListener(event: 'targetcreated', listener: (arg0 : Target) => void): this;

  /**
   * Emitted when a target is destroyed, for example when a page is closed.
   * 
   * **NOTE** This includes target destructions in incognito browser contexts.
   */
  addListener(event: 'targetdestroyed', listener: (arg0 : Target) => void): this;

  disconnected(): void;

  /**
   * Emitted when the url of a target changes.
   * 
   * **NOTE** This includes target changes in incognito browser contexts.
   */
  targetchanged(): Target;

  /**
   * Emitted when a target is created, for example when a new page is opened by `window.open` or `browser.newPage`.
   * 
   * **NOTE** This includes target creations in incognito browser contexts.
   */
  targetcreated(): Target;

  /**
   * Emitted when a target is destroyed, for example when a page is closed.
   * 
   * **NOTE** This includes target destructions in incognito browser contexts.
   */
  targetdestroyed(): Target;

  /**
   * Returns an array of all open browser contexts. In a newly created browser, this will return
   * a single instance of BrowserContext.
   */
  browserContexts(): Array<BrowserContext>;

  /**
   * Closes Chromium and all of its pages (if any were opened). The Browser object itself is considered to be disposed and cannot be used anymore.
   */
  close(): Promise<void>;

  /**
   * Creates a new incognito browser context. This won't share cookies/cache with other browser contexts.
   * ```js
   * const browser = await puppeteer.launch();
   * // Create a new incognito browser context.
   * const context = await browser.createIncognitoBrowserContext();
   * // Create a new page in a pristine context.
   * const page = await context.newPage();
   * // Do stuff
   * await page.goto('https://example.com');
   * ```
   */
  createIncognitoBrowserContext(): Promise<BrowserContext>;

  /**
   * Returns the default browser context. The default browser context can not be closed.
   */
  defaultBrowserContext(): BrowserContext;

  /**
   * browser.disconnect()
   * Disconnects Puppeteer from the browser, but leaves the Chromium process running. After calling `disconnect`, the Browser object is considered disposed and cannot be used anymore.
   */
  disconnect(): void;

  /**
   * Promise which resolves to a new Page object. The Page is created in a default browser context.
   */
  newPage(): Promise<Page>;

  /**
   * An array of all pages inside the Browser. In case of multiple browser contexts,
   * the method will return an array with all the pages in all browser contexts.
   * @returns Promise which resolves to an array of all open pages. Non visible pages, such as `"background_page"`, will not be listed here. You can find them using target.page().
   */
  pages(): Promise<Array<Page>>;

  /**
   * @returns Spawned browser process. Returns `null` if the browser instance was created with `puppeteer.connect` method.
   */
  process(): null|ChildProcess;

  /**
   * A target associated with the browser.
   */
  target(): Target;

  /**
   * An array of all active targets inside the Browser. In case of multiple browser contexts,
   * the method will return an array with all the targets in all browser contexts.
   */
  targets(): Array<Target>;

  /**
   * **NOTE** Pages can override browser user agent with page.setUserAgent
   * @returns Promise which resolves to the browser's original user agent.
   */
  userAgent(): Promise<string>;

  /**
   * **NOTE** the format of browser.version() might change with future releases of Chromium.
   * @returns For headless Chromium, this is similar to `HeadlessChrome/61.0.3153.0`. For non-headless, this is similar to `Chrome/61.0.3153.0`.
   */
  version(): Promise<string>;

  /**
   * This searches for a target in all browser contexts.
   * An example of finding a target for a page opened via `window.open`:
   * ```js
   * await page.evaluate(() => window.open('https://www.example.com/'));
   * const newWindowTarget = await browser.waitForTarget(target => target.url() === 'https://www.example.com/');
   * ```
   * @param predicate A function to be run for every target
   * @param options 
   * @returns Promise which resolves to the first target found that matches the `predicate` function.
   */
  waitForTarget(predicate: (arg0 : Target) => boolean, options?: BrowserWaitForTargetOptions): Promise<Target>;

  /**
   * Browser websocket endpoint which can be used as an argument to
   * puppeteer.connect. The format is `ws://${host}:${port}/devtools/browser/<id>`
   * You can find the `webSocketDebuggerUrl` from `http://${host}:${port}/json/version`. Learn more about the devtools protocol and the browser endpoint.
   * @returns Browser websocket url.
   */
  wsEndpoint(): string;
}

/**
 * BrowserContexts provide a way to operate multiple independent browser sessions. When a browser is launched, it has
 * a single BrowserContext used by default. The method `browser.newPage()` creates a page in the default browser context.
 * If a page opens another page, e.g. with a `window.open` call, the popup will belong to the parent page's browser
 * context.
 * Puppeteer allows creation of "incognito" browser contexts with `browser.createIncognitoBrowserContext()` method.
 * "Incognito" browser contexts don't write any browsing data to disk.
 * ```js
 * // Create a new incognito browser context
 * const context = await browser.createIncognitoBrowserContext();
 * // Create a new page inside context.
 * const page = await context.newPage();
 * // ... do stuff with page ...
 * await page.goto('https://example.com');
 * // Dispose context once it's no longer needed.
 * await context.close();
 * ```
 */
export interface BrowserContext extends EventEmitter {
  /**
   * Emitted when the url of a target inside the browser context changes.
   */
  on(event: 'targetchanged', listener: (arg0 : Target) => void): this;

  /**
   * Emitted when a new target is created inside the browser context, for example when a new page is opened by `window.open` or `browserContext.newPage`.
   */
  on(event: 'targetcreated', listener: (arg0 : Target) => void): this;

  /**
   * Emitted when a target inside the browser context is destroyed, for example when a page is closed.
   */
  on(event: 'targetdestroyed', listener: (arg0 : Target) => void): this;

  /**
   * Emitted when the url of a target inside the browser context changes.
   */
  once(event: 'targetchanged', listener: (arg0 : Target) => void): this;

  /**
   * Emitted when a new target is created inside the browser context, for example when a new page is opened by `window.open` or `browserContext.newPage`.
   */
  once(event: 'targetcreated', listener: (arg0 : Target) => void): this;

  /**
   * Emitted when a target inside the browser context is destroyed, for example when a page is closed.
   */
  once(event: 'targetdestroyed', listener: (arg0 : Target) => void): this;

  /**
   * Emitted when the url of a target inside the browser context changes.
   */
  addListener(event: 'targetchanged', listener: (arg0 : Target) => void): this;

  /**
   * Emitted when a new target is created inside the browser context, for example when a new page is opened by `window.open` or `browserContext.newPage`.
   */
  addListener(event: 'targetcreated', listener: (arg0 : Target) => void): this;

  /**
   * Emitted when a target inside the browser context is destroyed, for example when a page is closed.
   */
  addListener(event: 'targetdestroyed', listener: (arg0 : Target) => void): this;

  /**
   * Emitted when the url of a target inside the browser context changes.
   */
  targetchanged(): Target;

  /**
   * Emitted when a new target is created inside the browser context, for example when a new page is opened by `window.open` or `browserContext.newPage`.
   */
  targetcreated(): Target;

  /**
   * Emitted when a target inside the browser context is destroyed, for example when a page is closed.
   */
  targetdestroyed(): Target;

  /**
   * The browser this browser context belongs to.
   */
  browser(): Browser;

  /**
   * Clears all permission overrides for the browser context.
   * ```js
   * const context = browser.defaultBrowserContext();
   * context.overridePermissions('https://example.com', ['clipboard-read']);
   * // do stuff ..
   * context.clearPermissionOverrides();
   * ```
   */
  clearPermissionOverrides(): Promise<void>;

  /**
   * Closes the browser context. All the targets that belong to the browser context
   * will be closed.
   * 
   * **NOTE** only incognito browser contexts can be closed.
   */
  close(): Promise<void>;

  /**
   * Returns whether BrowserContext is incognito.
   * The default browser context is the only non-incognito browser context.
   * 
   * **NOTE** the default browser context cannot be closed.
   */
  isIncognito(): boolean;

  /**
   * Creates a new page in the browser context.
   */
  newPage(): Promise<Page>;

  /**
   * ```js
   * const context = browser.defaultBrowserContext();
   * await context.overridePermissions('https://html5demos.com', ['geolocation']);
   * ```
   * @param origin The origin to grant permissions to, e.g. "https://example.com".
   * @param permissions An array of permissions to grant. All permissions that are not listed here will be automatically denied. Permissions can be one of the following values:
   */
  overridePermissions(origin: string, permissions: Array<string>): Promise<void>;

  /**
   * An array of all pages inside the browser context.
   * @returns Promise which resolves to an array of all open pages. Non visible pages, such as `"background_page"`, will not be listed here. You can find them using target.page().
   */
  pages(): Promise<Array<Page>>;

  /**
   * An array of all active targets inside the browser context.
   */
  targets(): Array<Target>;

  /**
   * This searches for a target in this specific browser context.
   * An example of finding a target for a page opened via `window.open`:
   * ```js
   * await page.evaluate(() => window.open('https://www.example.com/'));
   * const newWindowTarget = await browserContext.waitForTarget(target => target.url() === 'https://www.example.com/');
   * ```
   * @param predicate A function to be run for every target
   * @param options 
   * @returns Promise which resolves to the first target found that matches the `predicate` function.
   */
  waitForTarget(predicate: (arg0 : Target) => boolean, options?: BrowserContextWaitForTargetOptions): Promise<Target>;
}

/**
 * Page provides methods to interact with a single tab or extension background page in Chromium. One Browser instance might have multiple Page instances.
 * This example creates a page, navigates it to a URL, and then saves a screenshot:
 * ```js
 * const puppeteer = require('puppeteer');
 * 
 * puppeteer.launch().then(async browser => {
 *   const page = await browser.newPage();
 *   await page.goto('https://example.com');
 *   await page.screenshot({path: 'screenshot.png'});
 *   await browser.close();
 * });
 * ```
 * The Page class emits various events (described below) which can be handled using any of Node's native `EventEmitter` methods, such as `on`, `once` or `removeListener`.
 * This example logs a message for a single page `load` event:
 * ```js
 * page.once('load', () => console.log('Page loaded!'));
 * ```
 * To unsubscribe from events use the `removeListener` method:
 * ```js
 * function logRequest(interceptedRequest) {
 *   console.log('A request was made:', interceptedRequest.url());
 * }
 * page.on('request', logRequest);
 * // Sometime later...
 * page.removeListener('request', logRequest);
 * ```
 */
export interface Page extends EventEmitter {
  /**
   * event: 'close'
   * Emitted when the page closes.
   */
  on(event: 'close', listener: (arg0 : void) => void): this;

  /**
   * Emitted when JavaScript within the page calls one of console API methods, e.g. `console.log` or `console.dir`. Also emitted if the page throws an error or a warning.
   * The arguments passed into `console.log` appear as arguments on the event handler.
   * An example of handling `console` event:
   * ```js
   * page.on('console', msg => {
   *   for (let i = 0; i < msg.args().length; ++i)
   *     console.log(`${i}: ${msg.args()[i]}`);
   * });
   * page.evaluate(() => console.log('hello', 5, {foo: 'bar'}));
   * ```
   */
  on(event: 'console', listener: (arg0 : ConsoleMessage) => void): this;

  /**
   * Emitted when a JavaScript dialog appears, such as `alert`, `prompt`, `confirm` or `beforeunload`. Puppeteer can respond to the dialog via Dialog's accept or dismiss methods.
   */
  on(event: 'dialog', listener: (arg0 : Dialog) => void): this;

  /**
   * event: 'domcontentloaded'
   * Emitted when the JavaScript `DOMContentLoaded` event is dispatched.
   */
  on(event: 'domcontentloaded', listener: (arg0 : void) => void): this;

  /**
   * Emitted when the page crashes.
   * 
   * **NOTE** `error` event has a special meaning in Node, see error events for details.
   */
  on(event: 'error', listener: (arg0 : Error) => void): this;

  /**
   * Emitted when a frame is attached.
   */
  on(event: 'frameattached', listener: (arg0 : Frame) => void): this;

  /**
   * Emitted when a frame is detached.
   */
  on(event: 'framedetached', listener: (arg0 : Frame) => void): this;

  /**
   * Emitted when a frame is navigated to a new url.
   */
  on(event: 'framenavigated', listener: (arg0 : Frame) => void): this;

  /**
   * event: 'load'
   * Emitted when the JavaScript `load` event is dispatched.
   */
  on(event: 'load', listener: (arg0 : void) => void): this;

  /**
   * Emitted when the JavaScript code makes a call to `console.timeStamp`. For the list
   * of metrics see `page.metrics`.
   */
  on(event: 'metrics', listener: (arg0 : PageMetricsPayload) => void): this;

  /**
   * Emitted when an uncaught exception happens within the page.
   */
  on(event: 'pageerror', listener: (arg0 : Error) => void): this;

  /**
   * Emitted when the page opens a new tab or window.
   * ```js
   * const [popup] = await Promise.all([
   *   new Promise(resolve => page.once('popup', resolve)),
   *   page.click('a[target=_blank]'),
   * ]);
   * ```
   * ```js
   * const [popup] = await Promise.all([
   *   new Promise(resolve => page.once('popup', resolve)),
   *   page.evaluate(() => window.open('https://example.com')),
   * ]);
   * ```
   */
  on(event: 'popup', listener: (arg0 : Page) => void): this;

  /**
   * Emitted when a page issues a request. The request object is read-only.
   * In order to intercept and mutate requests, see `page.setRequestInterception`.
   */
  on(event: 'request', listener: (arg0 : Request) => void): this;

  /**
   * Emitted when a request fails, for example by timing out.
   */
  on(event: 'requestfailed', listener: (arg0 : Request) => void): this;

  /**
   * Emitted when a request finishes successfully.
   */
  on(event: 'requestfinished', listener: (arg0 : Request) => void): this;

  /**
   * Emitted when a response is received.
   */
  on(event: 'response', listener: (arg0 : Response) => void): this;

  /**
   * Emitted when a dedicated WebWorker is spawned by the page.
   */
  on(event: 'workercreated', listener: (arg0 : Worker) => void): this;

  /**
   * Emitted when a dedicated WebWorker is terminated.
   */
  on(event: 'workerdestroyed', listener: (arg0 : Worker) => void): this;

  /**
   * event: 'close'
   * Emitted when the page closes.
   */
  once(event: 'close', listener: (arg0 : void) => void): this;

  /**
   * Emitted when JavaScript within the page calls one of console API methods, e.g. `console.log` or `console.dir`. Also emitted if the page throws an error or a warning.
   * The arguments passed into `console.log` appear as arguments on the event handler.
   * An example of handling `console` event:
   * ```js
   * page.on('console', msg => {
   *   for (let i = 0; i < msg.args().length; ++i)
   *     console.log(`${i}: ${msg.args()[i]}`);
   * });
   * page.evaluate(() => console.log('hello', 5, {foo: 'bar'}));
   * ```
   */
  once(event: 'console', listener: (arg0 : ConsoleMessage) => void): this;

  /**
   * Emitted when a JavaScript dialog appears, such as `alert`, `prompt`, `confirm` or `beforeunload`. Puppeteer can respond to the dialog via Dialog's accept or dismiss methods.
   */
  once(event: 'dialog', listener: (arg0 : Dialog) => void): this;

  /**
   * event: 'domcontentloaded'
   * Emitted when the JavaScript `DOMContentLoaded` event is dispatched.
   */
  once(event: 'domcontentloaded', listener: (arg0 : void) => void): this;

  /**
   * Emitted when the page crashes.
   * 
   * **NOTE** `error` event has a special meaning in Node, see error events for details.
   */
  once(event: 'error', listener: (arg0 : Error) => void): this;

  /**
   * Emitted when a frame is attached.
   */
  once(event: 'frameattached', listener: (arg0 : Frame) => void): this;

  /**
   * Emitted when a frame is detached.
   */
  once(event: 'framedetached', listener: (arg0 : Frame) => void): this;

  /**
   * Emitted when a frame is navigated to a new url.
   */
  once(event: 'framenavigated', listener: (arg0 : Frame) => void): this;

  /**
   * event: 'load'
   * Emitted when the JavaScript `load` event is dispatched.
   */
  once(event: 'load', listener: (arg0 : void) => void): this;

  /**
   * Emitted when the JavaScript code makes a call to `console.timeStamp`. For the list
   * of metrics see `page.metrics`.
   */
  once(event: 'metrics', listener: (arg0 : PageMetricsPayload) => void): this;

  /**
   * Emitted when an uncaught exception happens within the page.
   */
  once(event: 'pageerror', listener: (arg0 : Error) => void): this;

  /**
   * Emitted when the page opens a new tab or window.
   * ```js
   * const [popup] = await Promise.all([
   *   new Promise(resolve => page.once('popup', resolve)),
   *   page.click('a[target=_blank]'),
   * ]);
   * ```
   * ```js
   * const [popup] = await Promise.all([
   *   new Promise(resolve => page.once('popup', resolve)),
   *   page.evaluate(() => window.open('https://example.com')),
   * ]);
   * ```
   */
  once(event: 'popup', listener: (arg0 : Page) => void): this;

  /**
   * Emitted when a page issues a request. The request object is read-only.
   * In order to intercept and mutate requests, see `page.setRequestInterception`.
   */
  once(event: 'request', listener: (arg0 : Request) => void): this;

  /**
   * Emitted when a request fails, for example by timing out.
   */
  once(event: 'requestfailed', listener: (arg0 : Request) => void): this;

  /**
   * Emitted when a request finishes successfully.
   */
  once(event: 'requestfinished', listener: (arg0 : Request) => void): this;

  /**
   * Emitted when a response is received.
   */
  once(event: 'response', listener: (arg0 : Response) => void): this;

  /**
   * Emitted when a dedicated WebWorker is spawned by the page.
   */
  once(event: 'workercreated', listener: (arg0 : Worker) => void): this;

  /**
   * Emitted when a dedicated WebWorker is terminated.
   */
  once(event: 'workerdestroyed', listener: (arg0 : Worker) => void): this;

  /**
   * event: 'close'
   * Emitted when the page closes.
   */
  addListener(event: 'close', listener: (arg0 : void) => void): this;

  /**
   * Emitted when JavaScript within the page calls one of console API methods, e.g. `console.log` or `console.dir`. Also emitted if the page throws an error or a warning.
   * The arguments passed into `console.log` appear as arguments on the event handler.
   * An example of handling `console` event:
   * ```js
   * page.on('console', msg => {
   *   for (let i = 0; i < msg.args().length; ++i)
   *     console.log(`${i}: ${msg.args()[i]}`);
   * });
   * page.evaluate(() => console.log('hello', 5, {foo: 'bar'}));
   * ```
   */
  addListener(event: 'console', listener: (arg0 : ConsoleMessage) => void): this;

  /**
   * Emitted when a JavaScript dialog appears, such as `alert`, `prompt`, `confirm` or `beforeunload`. Puppeteer can respond to the dialog via Dialog's accept or dismiss methods.
   */
  addListener(event: 'dialog', listener: (arg0 : Dialog) => void): this;

  /**
   * event: 'domcontentloaded'
   * Emitted when the JavaScript `DOMContentLoaded` event is dispatched.
   */
  addListener(event: 'domcontentloaded', listener: (arg0 : void) => void): this;

  /**
   * Emitted when the page crashes.
   * 
   * **NOTE** `error` event has a special meaning in Node, see error events for details.
   */
  addListener(event: 'error', listener: (arg0 : Error) => void): this;

  /**
   * Emitted when a frame is attached.
   */
  addListener(event: 'frameattached', listener: (arg0 : Frame) => void): this;

  /**
   * Emitted when a frame is detached.
   */
  addListener(event: 'framedetached', listener: (arg0 : Frame) => void): this;

  /**
   * Emitted when a frame is navigated to a new url.
   */
  addListener(event: 'framenavigated', listener: (arg0 : Frame) => void): this;

  /**
   * event: 'load'
   * Emitted when the JavaScript `load` event is dispatched.
   */
  addListener(event: 'load', listener: (arg0 : void) => void): this;

  /**
   * Emitted when the JavaScript code makes a call to `console.timeStamp`. For the list
   * of metrics see `page.metrics`.
   */
  addListener(event: 'metrics', listener: (arg0 : PageMetricsPayload) => void): this;

  /**
   * Emitted when an uncaught exception happens within the page.
   */
  addListener(event: 'pageerror', listener: (arg0 : Error) => void): this;

  /**
   * Emitted when the page opens a new tab or window.
   * ```js
   * const [popup] = await Promise.all([
   *   new Promise(resolve => page.once('popup', resolve)),
   *   page.click('a[target=_blank]'),
   * ]);
   * ```
   * ```js
   * const [popup] = await Promise.all([
   *   new Promise(resolve => page.once('popup', resolve)),
   *   page.evaluate(() => window.open('https://example.com')),
   * ]);
   * ```
   */
  addListener(event: 'popup', listener: (arg0 : Page) => void): this;

  /**
   * Emitted when a page issues a request. The request object is read-only.
   * In order to intercept and mutate requests, see `page.setRequestInterception`.
   */
  addListener(event: 'request', listener: (arg0 : Request) => void): this;

  /**
   * Emitted when a request fails, for example by timing out.
   */
  addListener(event: 'requestfailed', listener: (arg0 : Request) => void): this;

  /**
   * Emitted when a request finishes successfully.
   */
  addListener(event: 'requestfinished', listener: (arg0 : Request) => void): this;

  /**
   * Emitted when a response is received.
   */
  addListener(event: 'response', listener: (arg0 : Response) => void): this;

  /**
   * Emitted when a dedicated WebWorker is spawned by the page.
   */
  addListener(event: 'workercreated', listener: (arg0 : Worker) => void): this;

  /**
   * Emitted when a dedicated WebWorker is terminated.
   */
  addListener(event: 'workerdestroyed', listener: (arg0 : Worker) => void): this;

  /**
   * event: 'close'
   * Emitted when the page closes.
   */
  close(): void;

  /**
   * Emitted when JavaScript within the page calls one of console API methods, e.g. `console.log` or `console.dir`. Also emitted if the page throws an error or a warning.
   * The arguments passed into `console.log` appear as arguments on the event handler.
   * An example of handling `console` event:
   * ```js
   * page.on('console', msg => {
   *   for (let i = 0; i < msg.args().length; ++i)
   *     console.log(`${i}: ${msg.args()[i]}`);
   * });
   * page.evaluate(() => console.log('hello', 5, {foo: 'bar'}));
   * ```
   */
  console(): ConsoleMessage;

  /**
   * Emitted when a JavaScript dialog appears, such as `alert`, `prompt`, `confirm` or `beforeunload`. Puppeteer can respond to the dialog via Dialog's accept or dismiss methods.
   */
  dialog(): Dialog;

  /**
   * event: 'domcontentloaded'
   * Emitted when the JavaScript `DOMContentLoaded` event is dispatched.
   */
  domcontentloaded(): void;

  /**
   * Emitted when the page crashes.
   * 
   * **NOTE** `error` event has a special meaning in Node, see error events for details.
   */
  error(): Error;

  /**
   * Emitted when a frame is attached.
   */
  frameattached(): Frame;

  /**
   * Emitted when a frame is detached.
   */
  framedetached(): Frame;

  /**
   * Emitted when a frame is navigated to a new url.
   */
  framenavigated(): Frame;

  /**
   * event: 'load'
   * Emitted when the JavaScript `load` event is dispatched.
   */
  load(): void;

  /**
   * Emitted when the JavaScript code makes a call to `console.timeStamp`. For the list
   * of metrics see `page.metrics`.
   */
  metrics(): PageMetrics;

  /**
   * Emitted when an uncaught exception happens within the page.
   */
  pageerror(): Error;

  /**
   * Emitted when the page opens a new tab or window.
   * ```js
   * const [popup] = await Promise.all([
   *   new Promise(resolve => page.once('popup', resolve)),
   *   page.click('a[target=_blank]'),
   * ]);
   * ```
   * ```js
   * const [popup] = await Promise.all([
   *   new Promise(resolve => page.once('popup', resolve)),
   *   page.evaluate(() => window.open('https://example.com')),
   * ]);
   * ```
   */
  popup(): Page;

  /**
   * Emitted when a page issues a request. The request object is read-only.
   * In order to intercept and mutate requests, see `page.setRequestInterception`.
   */
  request(): Request;

  /**
   * Emitted when a request fails, for example by timing out.
   */
  requestfailed(): Request;

  /**
   * Emitted when a request finishes successfully.
   */
  requestfinished(): Request;

  /**
   * Emitted when a response is received.
   */
  response(): Response;

  /**
   * Emitted when a dedicated WebWorker is spawned by the page.
   */
  workercreated(): Worker;

  /**
   * Emitted when a dedicated WebWorker is terminated.
   */
  workerdestroyed(): Worker;

  /**
   * The method runs `document.querySelector` within the page. If no element matches the selector, the return value resolves to `null`.
   * Shortcut for page.mainFrame().$(selector).
   * @param selector A selector to query page for
   */
  $(selector: string): Promise<null|ElementHandle>;

  /**
   * The method runs `document.querySelectorAll` within the page. If no elements match the selector, the return value resolves to `[]`.
   * Shortcut for page.mainFrame().$$(selector).
   * @param selector A selector to query page for
   */
  $$(selector: string): Promise<Array<ElementHandle>>;

  /**
   * This method runs `Array.from(document.querySelectorAll(selector))` within the page and passes it as the first argument to `pageFunction`.
   * If `pageFunction` returns a Promise, then `page.$$eval` would wait for the promise to resolve and return its value.
   * Examples:
   * ```js
   * const divsCounts = await page.$$eval('div', divs => divs.length);
   * ```
   * @param selector A selector to query page for
   * @param pageFunction Function to be evaluated in browser context
   * @param args Arguments to pass to `pageFunction`
   * @returns Promise which resolves to the return value of `pageFunction`
   */
  $$eval(selector: string, pageFunction: Function, ...args: Array<Serializable|JSHandle>): Promise<Serializable>;

  /**
   * This method runs `document.querySelector` within the page and passes it as the first argument to `pageFunction`. If there's no element matching `selector`, the method throws an error.
   * If `pageFunction` returns a Promise, then `page.$eval` would wait for the promise to resolve and return its value.
   * Examples:
   * ```js
   * const searchValue = await page.$eval('#search', el => el.value);
   * const preloadHref = await page.$eval('link[rel=preload]', el => el.href);
   * const html = await page.$eval('.main-container', e => e.outerHTML);
   * ```
   * Shortcut for page.mainFrame().$eval(selector, pageFunction).
   * @param selector A selector to query page for
   * @param asdf Function to be evaluated in browser context
   * @param args Arguments to pass to `pageFunction`
   * @returns Promise which resolves to the return value of `pageFunction`
   */
  $eval(selector: string, asdf: number, ...args: Array<Serializable|JSHandle>): Promise<Serializable>;

  /**
   * The method evaluates the XPath expression.
   * Shortcut for page.mainFrame().$x(expression)
   * @param expression Expression to evaluate.
   */
  $x(expression: string): Promise<Array<ElementHandle>>;

  accessibility: Accessibility;

  /**
   * Adds a `<script>` tag into the page with the desired url or content.
   * Shortcut for page.mainFrame().addScriptTag(options).
   * @param options 
   * @returns which resolves to the added tag when the script's onload fires or when the script content was injected into frame.
   */
  addScriptTag(options: PageAddScriptTagOptions): Promise<ElementHandle>;

  /**
   * Adds a `<link rel="stylesheet">` tag into the page with the desired url or a `<style type="text/css">` tag with the content.
   * Shortcut for page.mainFrame().addStyleTag(options).
   * @param options 
   * @returns which resolves to the added tag when the stylesheet's onload fires or when the CSS content was injected into frame.
   */
  addStyleTag(options: PageAddStyleTagOptions): Promise<ElementHandle>;

  /**
   * Provide credentials for HTTP authentication.
   * To disable authentication, pass `null`.
   * @param credentials 
   */
  authenticate(credentials: null|PageAuthenticateOptions): Promise<void>;

  /**
   * Brings page to front (activates tab).
   */
  bringToFront(): Promise<void>;

  /**
   * Get the browser the page belongs to.
   */
  browser(): Browser;

  /**
   * Get the browser context that the page belongs to.
   */
  browserContext(): BrowserContext;

  /**
   * This method fetches an element with `selector`, scrolls it into view if needed, and then uses page.mouse to click in the center of the element.
   * If there's no element matching `selector`, the method throws an error.
   * Bear in mind that if `click()` triggers a navigation event and there's a separate `page.waitForNavigation()` promise to be resolved, you may end up with a race condition that yields unexpected results. The correct pattern for click and wait for navigation is the following:
   * ```javascript
   * const [response] = await Promise.all([
   *   page.waitForNavigation(waitOptions),
   *   page.click(selector, clickOptions),
   * ]);
   * ```
   * Shortcut for page.mainFrame().click(selector[, options]).
   * @param selector A selector to search for element to click. If there are multiple elements satisfying the selector, the first will be clicked.
   * @param options 
   * @returns Promise which resolves when the element matching `selector` is successfully clicked. The Promise will be rejected if there is no element matching `selector`.
   */
  click(selector: string, options?: PageClickOptions): Promise<void>;

  /**
   * By default, `page.close()` **does not** run beforeunload handlers.
   * 
   * **NOTE** if `runBeforeUnload` is passed as true, a `beforeunload` dialog might be summoned
   * and should be handled manually via page's 'dialog' event.
   * @param options 
   */
  close(options?: PageCloseOptions): Promise<void>;

  /**
   * Gets the full HTML contents of the page, including the doctype.
   */
  content(): Promise<string>;

  /**
   * If no URLs are specified, this method returns cookies for the current page URL.
   * If URLs are specified, only cookies for those URLs are returned.
   * @param urls 
   */
  cookies(...urls: Array<string>): Promise<Array<PageCookies>>;

  coverage: Coverage;

  /**
   * @param cookies 
   */
  deleteCookie(...cookies: Array<PageDeleteCookieOptions>): Promise<void>;

  /**
   * Emulates given device metrics and user agent. This method is a shortcut for calling two methods:
   * 
   * page.setUserAgent(userAgent)
   * page.setViewport(viewport)
   * 
   * To aid emulation, puppeteer provides a list of device descriptors which can be obtained via the `require('puppeteer/DeviceDescriptors')` command.
   * Below is an example of emulating an iPhone 6 in puppeteer:
   * ```js
   * const puppeteer = require('puppeteer');
   * const devices = require('puppeteer/DeviceDescriptors');
   * const iPhone = devices['iPhone 6'];
   * 
   * puppeteer.launch().then(async browser => {
   *   const page = await browser.newPage();
   *   await page.emulate(iPhone);
   *   await page.goto('https://www.google.com');
   *   // other actions...
   *   await browser.close();
   * });
   * ```
   * List of all available devices is available in the source code: DeviceDescriptors.js.
   * @param options 
   */
  emulate(options: PageEmulateOptions): Promise<void>;

  /**
   * @param mediaType Changes the CSS media type of the page. The only allowed values are `'screen'`, `'print'` and `null`. Passing `null` disables media emulation.
   */
  emulateMedia(mediaType: null|string): Promise<void>;

  /**
   * If the function passed to the `page.evaluate` returns a Promise, then `page.evaluate` would wait for the promise to resolve and return its value.
   * If the function passed to the `page.evaluate` returns a non-Serializable value, then `page.evaluate` resolves to `undefined`.
   * Passing arguments to `pageFunction`:
   * ```js
   * const result = await page.evaluate(x => {
   *   return Promise.resolve(8 * x);
   * }, 7);
   * console.log(result); // prints "56"
   * ```
   * A string can also be passed in instead of a function:
   * ```js
   * console.log(await page.evaluate('1 + 2')); // prints "3"
   * const x = 10;
   * console.log(await page.evaluate(`1 + ${x}`)); // prints "11"
   * ```
   * ElementHandle instances can be passed as arguments to the `page.evaluate`:
   * ```js
   * const bodyHandle = await page.$('body');
   * const html = await page.evaluate(body => body.innerHTML, bodyHandle);
   * await bodyHandle.dispose();
   * ```
   * Shortcut for page.mainFrame().evaluate(pageFunction, ...args).
   * @param pageFunction Function to be evaluated in the page context
   * @param args Arguments to pass to `pageFunction`
   * @returns Promise which resolves to the return value of `pageFunction`
   */
  evaluate(pageFunction: Function|string, ...args: Array<Serializable|JSHandle>): Promise<Serializable>;

  /**
   * The only difference between `page.evaluate` and `page.evaluateHandle` is that `page.evaluateHandle` returns in-page object (JSHandle).
   * If the function passed to the `page.evaluateHandle` returns a Promise, then `page.evaluateHandle` would wait for the promise to resolve and return its value.
   * A string can also be passed in instead of a function:
   * ```js
   * const aHandle = await page.evaluateHandle('document'); // Handle for the 'document'
   * ```
   * JSHandle instances can be passed as arguments to the `page.evaluateHandle`:
   * ```js
   * const aHandle = await page.evaluateHandle(() => document.body);
   * const resultHandle = await page.evaluateHandle(body => body.innerHTML, aHandle);
   * console.log(await resultHandle.jsonValue());
   * await resultHandle.dispose();
   * ```
   * Shortcut for page.mainFrame().executionContext().evaluateHandle(pageFunction, ...args).
   * @param pageFunction Function to be evaluated in the page context
   * @param args Arguments to pass to `pageFunction`
   * @returns Promise which resolves to the return value of `pageFunction` as in-page object (JSHandle)
   */
  evaluateHandle(pageFunction: Function|string, ...args: Array<Serializable|JSHandle>): Promise<JSHandle>;

  /**
   * Adds a function which would be invoked in one of the following scenarios:
   * 
   * whenever the page is navigated
   * whenever the child frame is attached or navigated. In this case, the function is invoked in the context of the newly attached frame
   * 
   * The function is invoked after the document was created but before any of its scripts were run. This is useful to amend  the JavaScript environment, e.g. to seed `Math.random`.
   * An example of overriding the navigator.languages property before the page loads:
   * ```js
   * // preload.js
   * 
   * // overwrite the `languages` property to use a custom getter
   * Object.defineProperty(navigator, "languages", {
   *   get: function() {
   *     return ["en-US", "en", "bn"];
   *   }
   * });
   * 
   * // In your puppeteer script, assuming the preload.js file is in same folder of our script
   * const preloadFile = fs.readFileSync('./preload.js', 'utf8');
   * await page.evaluateOnNewDocument(preloadFile);
   * ```
   * @param pageFunction Function to be evaluated in browser context
   * @param args Arguments to pass to `pageFunction`
   */
  evaluateOnNewDocument(pageFunction: Function|string, ...args: Array<Serializable>): Promise<void>;

  /**
   * The method adds a function called `name` on the page's `window` object.
   * When called, the function executes `puppeteerFunction` in node.js and returns a Promise which resolves to the return value of `puppeteerFunction`.
   * If the `puppeteerFunction` returns a Promise, it will be awaited.
   * 
   * **NOTE** Functions installed via `page.exposeFunction` survive navigations.
   * 
   * An example of adding an `md5` function into the page:
   * ```js
   * const puppeteer = require('puppeteer');
   * const crypto = require('crypto');
   * 
   * puppeteer.launch().then(async browser => {
   *   const page = await browser.newPage();
   *   page.on('console', msg => console.log(msg.text()));
   *   await page.exposeFunction('md5', text =>
   *     crypto.createHash('md5').update(text).digest('hex')
   *   );
   *   await page.evaluate(async () => {
   *     // use window.md5 to compute hashes
   *     const myString = 'PUPPETEER';
   *     const myHash = await window.md5(myString);
   *     console.log(`md5 of ${myString} is ${myHash}`);
   *   });
   *   await browser.close();
   * });
   * ```
   * An example of adding a `window.readfile` function into the page:
   * ```js
   * const puppeteer = require('puppeteer');
   * const fs = require('fs');
   * 
   * puppeteer.launch().then(async browser => {
   *   const page = await browser.newPage();
   *   page.on('console', msg => console.log(msg.text()));
   *   await page.exposeFunction('readfile', async filePath => {
   *     return new Promise((resolve, reject) => {
   *       fs.readFile(filePath, 'utf8', (err, text) => {
   *         if (err)
   *           reject(err);
   *         else
   *           resolve(text);
   *       });
   *     });
   *   });
   *   await page.evaluate(async () => {
   *     // use window.readfile to read contents of a file
   *     const content = await window.readfile('/etc/hosts');
   *     console.log(content);
   *   });
   *   await browser.close();
   * });
   * 
   * ```
   * @param name Name of the function on the window object
   * @param puppeteerFunction Callback function which will be called in Puppeteer's context.
   */
  exposeFunction(name: string, puppeteerFunction: Function): Promise<void>;

  /**
   * This method fetches an element with `selector` and focuses it.
   * If there's no element matching `selector`, the method throws an error.
   * Shortcut for page.mainFrame().focus(selector).
   * @param selector A selector of an element to focus. If there are multiple elements satisfying the selector, the first will be focused.
   * @returns Promise which resolves when the element matching `selector` is successfully focused. The promise will be rejected if there is no element matching `selector`.
   */
  focus(selector: string): Promise<void>;

  /**
   * @returns An array of all frames attached to the page.
   */
  frames(): Array<Frame>;

  /**
   * Navigate to the previous page in history.
   * @param options Navigation parameters which might have the following properties:
   * @returns Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect. If
can not go back, resolves to `null`.
   */
  goBack(options?: PageGoBackOptions): Promise<null|Response>;

  /**
   * Navigate to the next page in history.
   * @param options Navigation parameters which might have the following properties:
   * @returns Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect. If
can not go forward, resolves to `null`.
   */
  goForward(options?: PageGoForwardOptions): Promise<null|Response>;

  /**
   * The `page.goto` will throw an error if:
   * 
   * there's an SSL error (e.g. in case of self-signed certificates).
   * target URL is invalid.
   * the `timeout` is exceeded during navigation.
   * the main resource failed to load.
   * 
   * 
   * **NOTE** `page.goto` either throw or return a main resource response. The only exceptions are navigation to `about:blank` or navigation to the same URL with a different hash, which would succeed and return `null`.
   * 
   * 
   * **NOTE** Headless mode doesn't support navigation to a PDF document. See the upstream issue.
   * 
   * Shortcut for page.mainFrame().goto(url, options)
   * @param url URL to navigate page to. The url should include scheme, e.g. `https://`.
   * @param options Navigation parameters which might have the following properties:
   * @returns Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect.
   */
  goto(url: string, options?: PageGotoOptions): Promise<null|Response>;

  /**
   * This method fetches an element with `selector`, scrolls it into view if needed, and then uses page.mouse to hover over the center of the element.
   * If there's no element matching `selector`, the method throws an error.
   * Shortcut for page.mainFrame().hover(selector).
   * @param selector A selector to search for element to hover. If there are multiple elements satisfying the selector, the first will be hovered.
   * @returns Promise which resolves when the element matching `selector` is successfully hovered. Promise gets rejected if there's no element matching `selector`.
   */
  hover(selector: string): Promise<void>;

  /**
   * Indicates that the page has been closed.
   */
  isClosed(): boolean;

  keyboard: Keyboard;

  /**
   * Page is guaranteed to have a main frame which persists during navigations.
   * @returns The page's main frame.
   */
  mainFrame(): Frame;

  /**
   * **NOTE** All timestamps are in monotonic time: monotonically increasing time in seconds since an arbitrary point in the past.
   * @returns Object containing metrics as key/value pairs.
   */
  metrics(): Promise<PageMetrics>;

  mouse: Mouse;

  /**
   * **NOTE** Generating a pdf is currently only supported in Chrome headless.
   * 
   * `page.pdf()` generates a pdf of the page with `print` css media. To generate a pdf with `screen` media, call page.emulateMedia('screen') before calling `page.pdf()`:
   * 
   * **NOTE** By default, `page.pdf()` generates a pdf with modified colors for printing. Use the `-webkit-print-color-adjust` property to force rendering of exact colors.
   * 
   * ```js
   * // Generates a PDF with 'screen' media type.
   * await page.emulateMedia('screen');
   * await page.pdf({path: 'page.pdf'});
   * ```
   * The `width`, `height`, and `margin` options accept values labeled with units. Unlabeled values are treated as pixels.
   * A few examples:
   * 
   * `page.pdf({width: 100})` - prints with width set to 100 pixels
   * `page.pdf({width: '100px'})` - prints with width set to 100 pixels
   * `page.pdf({width: '10cm'})` - prints with width set to 10 centimeters.
   * 
   * All possible units are:
   * 
   * `px` - pixel
   * `in` - inch
   * `cm` - centimeter
   * `mm` - millimeter
   * 
   * The `format` options are:
   * 
   * `Letter`: 8.5in x 11in
   * `Legal`: 8.5in x 14in
   * `Tabloid`: 11in x 17in
   * `Ledger`: 17in x 11in
   * `A0`: 33.1in x 46.8in
   * `A1`: 23.4in x 33.1in
   * `A2`: 16.5in x 23.4in
   * `A3`: 11.7in x 16.5in
   * `A4`: 8.27in x 11.7in
   * `A5`: 5.83in x 8.27in
   * `A6`: 4.13in x 5.83in
   * 
   * 
   * **NOTE** `headerTemplate` and `footerTemplate` markup have the following limitations:
   * 
   * Script tags inside templates are not evaluated.
   * Page styles are not visible inside templates.
   * @param options Options object which might have the following properties:
   * @returns Promise which resolves with PDF buffer.
   */
  pdf(options?: PagePdfOptions): Promise<Buffer>;

  /**
   * The method iterates the JavaScript heap and finds all the objects with the given prototype.
   * ```js
   * // Create a Map object
   * await page.evaluate(() => window.map = new Map());
   * // Get a handle to the Map object prototype
   * const mapPrototype = await page.evaluateHandle(() => Map.prototype);
   * // Query all map instances into an array
   * const mapInstances = await page.queryObjects(mapPrototype);
   * // Count amount of map objects in heap
   * const count = await page.evaluate(maps => maps.length, mapInstances);
   * await mapInstances.dispose();
   * await mapPrototype.dispose();
   * ```
   * Shortcut for page.mainFrame().executionContext().queryObjects(prototypeHandle).
   * @param prototypeHandle A handle to the object prototype.
   * @returns Promise which resolves to a handle to an array of objects with this prototype.
   */
  queryObjects(prototypeHandle: JSHandle): Promise<JSHandle>;

  /**
   * @param options Navigation parameters which might have the following properties:
   * @returns Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect.
   */
  reload(options?: PageReloadOptions): Promise<Response>;

  /**
   * **NOTE** Screenshots take at least 1/6 second on OS X. See https://crbug.com/741689 for discussion.
   * @param options Options object which might have the following properties:
   * @returns Promise which resolves to buffer or a base64 string (depending on the value of `encoding`) with captured screenshot.
   */
  screenshot(options?: PageScreenshotOptions): Promise<string|Buffer>;

  /**
   * Triggers a `change` and `input` event once all the provided options have been selected.
   * If there's no `<select>` element matching `selector`, the method throws an error.
   * ```js
   * page.select('select#colors', 'blue'); // single selection
   * page.select('select#colors', 'red', 'green', 'blue'); // multiple selections
   * ```
   * Shortcut for page.mainFrame().select()
   * @param selector A selector to query page for
   * @param values Values of options to select. If the `<select>` has the `multiple` attribute, all values are considered, otherwise only the first one is taken into account.
   * @returns An array of option values that have been successfully selected.
   */
  select(selector: string, ...values: Array<string>): Promise<Array<string>>;

  /**
   * Toggles bypassing page's Content-Security-Policy.
   * 
   * **NOTE** CSP bypassing happens at the moment of CSP initialization rather then evaluation. Usually this means
   * that `page.setBypassCSP` should be called before navigating to the domain.
   * @param enabled sets bypassing of page's Content-Security-Policy.
   */
  setBypassCSP(enabled: boolean): Promise<void>;

  /**
   * Toggles ignoring cache for each request based on the enabled state. By default, caching is enabled.
   * @param enabled sets the `enabled` state of the cache.
   */
  setCacheEnabled(enabled?: boolean): Promise<void>;

  /**
   * @param html HTML markup to assign to the page.
   * @param options Parameters which might have the following properties:
   */
  setContent(html: string, options?: PageSetContentOptions): Promise<void>;

  /**
   * ```js
   * await page.setCookie(cookieObject1, cookieObject2);
   * ```
   * @param cookies 
   */
  setCookie(...cookies: Array<PageSetCookieOptions>): Promise<void>;

  /**
   * This setting will change the default maximum navigation time of 30 seconds for the following methods:
   * 
   * page.goto(url[, options])
   * page.goBack([options])
   * page.goForward([options])
   * page.reload([options])
   * page.waitForNavigation([options])
   * @param timeout Maximum navigation time in milliseconds
   */
  setDefaultNavigationTimeout(timeout: number): void;

  /**
   * The extra HTTP headers will be sent with every request the page initiates.
   * 
   * **NOTE** page.setExtraHTTPHeaders does not guarantee the order of headers in the outgoing requests.
   * @param headers An object containing additional HTTP headers to be sent with every request. All header values must be strings.
   */
  setExtraHTTPHeaders(headers: Object): Promise<void>;

  /**
   * Sets the page's geolocation.
   * ```js
   * await page.setGeolocation({latitude: 59.95, longitude: 30.31667});
   * ```
   * 
   * **NOTE** Consider using browserContext.overridePermissions to grant permissions for the page to read its geolocation.
   * @param options 
   */
  setGeolocation(options: PageSetGeolocationOptions): Promise<void>;

  /**
   * **NOTE** changing this value won't affect scripts that have already been run. It will take full effect on the next navigation.
   * @param enabled Whether or not to enable JavaScript on the page.
   */
  setJavaScriptEnabled(enabled: boolean): Promise<void>;

  /**
   * @param enabled When `true`, enables offline mode for the page.
   */
  setOfflineMode(enabled: boolean): Promise<void>;

  /**
   * Activating request interception enables `request.abort`, `request.continue` and
   * `request.respond` methods.  This provides the capability to modify network requests that are made by a page.
   * Once request interception is enabled, every request will stall unless it's continued, responded or aborted.
   * An example of a nave request interceptor that aborts all image requests:
   * ```js
   * const puppeteer = require('puppeteer');
   * 
   * puppeteer.launch().then(async browser => {
   *   const page = await browser.newPage();
   *   await page.setRequestInterception(true);
   *   page.on('request', interceptedRequest => {
   *     if (interceptedRequest.url().endsWith('.png') || interceptedRequest.url().endsWith('.jpg'))
   *       interceptedRequest.abort();
   *     else
   *       interceptedRequest.continue();
   *   });
   *   await page.goto('https://example.com');
   *   await browser.close();
   * });
   * ```
   * 
   * **NOTE** Enabling request interception disables page caching.
   * @param value Whether to enable request interception.
   */
  setRequestInterception(value: boolean): Promise<void>;

  /**
   * @param userAgent Specific user agent to use in this page
   * @returns Promise which resolves when the user agent is set.
   */
  setUserAgent(userAgent: string): Promise<void>;

  /**
   * **NOTE** in certain cases, setting viewport will reload the page in order to set the `isMobile` or `hasTouch` properties.
   * 
   * In the case of multiple pages in a single browser, each page can have its own viewport size.
   * @param viewport 
   */
  setViewport(viewport: PageSetViewportOptions): Promise<void>;

  /**
   * This method fetches an element with `selector`, scrolls it into view if needed, and then uses page.touchscreen to tap in the center of the element.
   * If there's no element matching `selector`, the method throws an error.
   * Shortcut for page.mainFrame().tap(selector).
   * @param selector A selector to search for element to tap. If there are multiple elements satisfying the selector, the first will be tapped.
   */
  tap(selector: string): Promise<void>;

  /**
   * @returns a target this page was created from.
   */
  target(): Target;

  /**
   * Shortcut for page.mainFrame().title().
   * @returns The page's title.
   */
  title(): Promise<string>;

  touchscreen: Touchscreen;

  tracing: Tracing;

  /**
   * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text.
   * To press a special key, like `Control` or `ArrowDown`, use `keyboard.press`.
   * ```js
   * page.type('#mytextarea', 'Hello'); // Types instantly
   * page.type('#mytextarea', 'World', {delay: 100}); // Types slower, like a user
   * ```
   * Shortcut for page.mainFrame().type(selector, text[, options]).
   * @param selector A selector of an element to type into. If there are multiple elements satisfying the selector, the first will be used.
   * @param text A text to type into a focused element.
   * @param options 
   */
  type(selector: string, text: string, options?: PageTypeOptions): Promise<void>;

  /**
   * This is a shortcut for page.mainFrame().url()
   */
  url(): string;

  viewport(): null|PageViewport;

  /**
   * This method behaves differently with respect to the type of the first parameter:
   * 
   * if `selectorOrFunctionOrTimeout` is a `string`, then the first argument is treated as a selector or xpath, depending on whether or not it starts with '//', and the method is a shortcut for
   * page.waitForSelector or page.waitForXPath
   * if `selectorOrFunctionOrTimeout` is a `function`, then the first argument is treated as a predicate to wait for and the method is a shortcut for page.waitForFunction().
   * if `selectorOrFunctionOrTimeout` is a `number`, then the first argument is treated as a timeout in milliseconds and the method returns a promise which resolves after the timeout
   * otherwise, an exception is thrown
   * 
   * ```js
   * // wait for selector
   * await page.waitFor('.foo');
   * // wait for 1 second
   * await page.waitFor(1000);
   * // wait for predicate
   * await page.waitFor(() => !!document.querySelector('.foo'));
   * ```
   * To pass arguments from node.js to the predicate of `page.waitFor` function:
   * ```js
   * const selector = '.foo';
   * await page.waitFor(selector => !!document.querySelector(selector), {}, selector);
   * ```
   * Shortcut for page.mainFrame().waitFor(selectorOrFunctionOrTimeout[, options[, ...args]]).
   * @param selectorOrFunctionOrTimeout A selector, predicate or timeout to wait for
   * @param options Optional waiting parameters
   * @param args Arguments to pass to  `pageFunction`
   * @returns Promise which resolves to a JSHandle of the success value
   */
  waitFor(selectorOrFunctionOrTimeout: string|number|Function, options?: Object, ...args: Array<Serializable|JSHandle>): Promise<JSHandle>;

  /**
   * The `waitForFunction` can be used to observe viewport size change:
   * ```js
   * const puppeteer = require('puppeteer');
   * 
   * puppeteer.launch().then(async browser => {
   *   const page = await browser.newPage();
   *   const watchDog = page.waitForFunction('window.innerWidth < 100');
   *   await page.setViewport({width: 50, height: 50});
   *   await watchDog;
   *   await browser.close();
   * });
   * ```
   * To pass arguments from node.js to the predicate of `page.waitForFunction` function:
   * ```js
   * const selector = '.foo';
   * await page.waitForFunction(selector => !!document.querySelector(selector), {}, selector);
   * ```
   * Shortcut for page.mainFrame().waitForFunction(pageFunction[, options[, ...args]]).
   * @param pageFunction Function to be evaluated in browser context
   * @param options Optional waiting parameters
   * @param args Arguments to pass to  `pageFunction`
   * @returns Promise which resolves when the `pageFunction` returns a truthy value. It resolves to a JSHandle of the truthy value.
   */
  waitForFunction(pageFunction: Function|string, options?: PageWaitForFunctionOptions, ...args: Array<Serializable|JSHandle>): Promise<JSHandle>;

  /**
   * This resolves when the page navigates to a new URL or reloads. It is useful for when you run code
   * which will indirectly cause the page to navigate. Consider this example:
   * ```js
   * const [response] = await Promise.all([
   *   page.waitForNavigation(), // The promise resolves after navigation has finished
   *   page.click('a.my-link'), // Clicking the link will indirectly cause a navigation
   * ]);
   * ```
   * **NOTE** Usage of the History API to change the URL is considered a navigation.
   * Shortcut for page.mainFrame().waitForNavigation(options).
   * @param options Navigation parameters which might have the following properties:
   * @returns Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect. In case of navigation to a different anchor or navigation due to History API usage, the navigation will resolve with `null`.
   */
  waitForNavigation(options?: PageWaitForNavigationOptions): Promise<null|Response>;

  /**
   * ```js
   * const firstRequest = await page.waitForRequest('http://example.com/resource');
   * const finalRequest = await page.waitForRequest(request => request.url() === 'http://example.com' && request.method() === 'GET');
   * return firstRequest.url();
   * ```
   * @param urlOrPredicate A URL or predicate to wait for.
   * @param options Optional waiting parameters
   * @returns Promise which resolves to the matched request.
   */
  waitForRequest(urlOrPredicate: string|Function, options?: PageWaitForRequestOptions): Promise<Request>;

  /**
   * ```js
   * const firstResponse = await page.waitForResponse('https://example.com/resource');
   * const finalResponse = await page.waitForResponse(response => response.url() === 'https://example.com' && response.status() === 200);
   * return finalResponse.ok();
   * ```
   * @param urlOrPredicate A URL or predicate to wait for.
   * @param options Optional waiting parameters
   * @returns Promise which resolves to the matched response.
   */
  waitForResponse(urlOrPredicate: string|Function, options?: PageWaitForResponseOptions): Promise<Response>;

  /**
   * Wait for the `selector` to appear in page. If at the moment of calling
   * the method the `selector` already exists, the method will return
   * immediately. If the selector doesn't appear after the `timeout` milliseconds of waiting, the function will throw.
   * This method works across navigations:
   * ```js
   * const puppeteer = require('puppeteer');
   * 
   * puppeteer.launch().then(async browser => {
   *   const page = await browser.newPage();
   *   let currentURL;
   *   page
   *     .waitForSelector('img')
   *     .then(() => console.log('First URL with image: ' + currentURL));
   *   for (currentURL of ['https://example.com', 'https://google.com', 'https://bbc.com'])
   *     await page.goto(currentURL);
   *   await browser.close();
   * });
   * ```
   * Shortcut for page.mainFrame().waitForSelector(selector[, options]).
   * @param selector A selector of an element to wait for
   * @param options Optional waiting parameters
   * @returns Promise which resolves when element specified by selector string is added to DOM.
   */
  waitForSelector(selector: string, options?: PageWaitForSelectorOptions): Promise<ElementHandle>;

  /**
   * Wait for the `xpath` to appear in page. If at the moment of calling
   * the method the `xpath` already exists, the method will return
   * immediately. If the xpath doesn't appear after the `timeout` milliseconds of waiting, the function will throw.
   * This method works across navigations:
   * ```js
   * const puppeteer = require('puppeteer');
   * 
   * puppeteer.launch().then(async browser => {
   *   const page = await browser.newPage();
   *   let currentURL;
   *   page
   *     .waitForXPath('//img')
   *     .then(() => console.log('First URL with image: ' + currentURL));
   *   for (currentURL of ['https://example.com', 'https://google.com', 'https://bbc.com'])
   *     await page.goto(currentURL);
   *   await browser.close();
   * });
   * ```
   * Shortcut for page.mainFrame().waitForXPath(xpath[, options]).
   * @param xpath A xpath of an element to wait for
   * @param options Optional waiting parameters
   * @returns Promise which resolves when element specified by xpath string is added to DOM.
   */
  waitForXPath(xpath: string, options?: PageWaitForXPathOptions): Promise<ElementHandle>;

  /**
   * **NOTE** This does not contain ServiceWorkers
   * @returns This method returns all of the dedicated WebWorkers associated with the page.
   */
  workers(): Array<Worker>;
}

/**
 * The Worker class represents a WebWorker.
 * The events `workercreated` and `workerdestroyed` are emitted on the page object to signal the worker lifecycle.
 * ```js
 * page.on('workercreated', worker => console.log('Worker created: ' + worker.url()));
 * page.on('workerdestroyed', worker => console.log('Worker destroyed: ' + worker.url()));
 * 
 * console.log('Current workers:');
 * for (const worker of page.workers())
 *   console.log('  ' + worker.url());
 * ```
 */
export interface Worker {
  /**
   * If the function passed to the `worker.evaluate` returns a Promise, then `worker.evaluate` would wait for the promise to resolve and return its value.
   * If the function passed to the `worker.evaluate` returns a non-Serializable value, then `worker.evaluate` resolves to `undefined`.
   * Shortcut for (await worker.executionContext()).evaluate(pageFunction, ...args).
   * @param pageFunction Function to be evaluated in the worker context
   * @param args Arguments to pass to `pageFunction`
   * @returns Promise which resolves to the return value of `pageFunction`
   */
  evaluate(pageFunction: Function|string, ...args: Array<Serializable|JSHandle>): Promise<Serializable>;

  /**
   * The only difference between `worker.evaluate` and `worker.evaluateHandle` is that `worker.evaluateHandle` returns in-page object (JSHandle).
   * If the function passed to the `worker.evaluateHandle` returns a Promise, then `worker.evaluateHandle` would wait for the promise to resolve and return its value.
   * Shortcut for (await worker.executionContext()).evaluateHandle(pageFunction, ...args).
   * @param pageFunction Function to be evaluated in the page context
   * @param args Arguments to pass to `pageFunction`
   * @returns Promise which resolves to the return value of `pageFunction` as in-page object (JSHandle)
   */
  evaluateHandle(pageFunction: Function|string, ...args: Array<Serializable|JSHandle>): Promise<JSHandle>;

  executionContext(): Promise<ExecutionContext>;

  url(): string;
}

/**
 * The Accessibility class provides methods for inspecting Chromium's accessibility tree. The accessibility tree is used by assistive technology such as screen readers.
 * Accessibility is a very platform-specific thing. On different platforms, there are different screen readers that might have wildly different output.
 * Blink - Chrome's rendering engine - has a concept of "accessibility tree", which is than translated into different platform-specific APIs. Accessibility namespace gives users
 * access to the Blink Accessibility Tree.
 * Most of the accessibility tree gets filtered out when converting from Blink AX Tree to Platform-specific AX-Tree or by screen readers themselves. By default, Puppeteer tries to approximate this filtering, exposing only the "interesting" nodes of the tree.
 */
export interface Accessibility {
  /**
   * Captures the current state of the accessibility tree. The returned object represents the root accessible node of the page.
   * 
   * **NOTE** The Chromium accessibility tree contains nodes that go unused on most platforms and by
   * most screen readers. Puppeteer will discard them as well for an easier to process tree,
   * unless `interestingOnly` is set to `false`.
   * 
   * An example of dumping the entire accessibility tree:
   * ```js
   * const snapshot = await page.accessibility.snapshot();
   * console.log(snapshot);
   * ```
   * An example of logging the focused node's name:
   * ```js
   * const snapshot = await page.accessibility.snapshot();
   * const node = findFocusedNode(snapshot);
   * console.log(node && node.name);
   * 
   * function findFocusedNode(node) {
   *   if (node.focused)
   *     return node;
   *   for (const child of node.children || []) {
   *     const foundNode = findFocusedNode(child);
   *     return foundNode;
   *   }
   *   return null;
   * }
   * ```
   * @param options 
   * @returns An AXNode object with the following properties:
   */
  snapshot(options?: AccessibilitySnapshotOptions): Promise<AccessibilitySnapshot>;
}

/**
 * Keyboard provides an api for managing a virtual keyboard. The high level api is `keyboard.type`, which takes raw characters and generates proper keydown, keypress/input, and keyup events on your page.
 * For finer control, you can use `keyboard.down`, `keyboard.up`, and `keyboard.sendCharacter` to manually fire events as if they were generated from a real keyboard.
 * An example of holding down `Shift` in order to select and delete some text:
 * ```js
 * await page.keyboard.type('Hello World!');
 * await page.keyboard.press('ArrowLeft');
 * 
 * await page.keyboard.down('Shift');
 * for (let i = 0; i < ' World'.length; i++)
 *   await page.keyboard.press('ArrowLeft');
 * await page.keyboard.up('Shift');
 * 
 * await page.keyboard.press('Backspace');
 * // Result text will end up saying 'Hello!'
 * ```
 * An example of pressing `A`
 * ```js
 * await page.keyboard.down('Shift');
 * await page.keyboard.press('KeyA');
 * await page.keyboard.up('Shift');
 * ```
 * 
 * **NOTE** On MacOS, keyboard shortcuts like ` A` -> Select All do not work. See #1313
 */
export interface Keyboard {
  /**
   * Dispatches a `keydown` event.
   * If `key` is a single character and no modifier keys besides `Shift` are being held down, a `keypress`/`input` event will also generated. The `text` option can be specified to force an input event to be generated.
   * If `key` is a modifier key, `Shift`, `Meta`, `Control`, or `Alt`, subsequent key presses will be sent with that modifier active. To release the modifier key, use `keyboard.up`.
   * After the key is pressed once, subsequent calls to `keyboard.down` will have repeat set to true. To release the key, use `keyboard.up`.
   * 
   * **NOTE** Modifier keys DO influence `keyboard.down`. Holding down `Shift` will type the text in upper case.
   * @param key Name of key to press, such as `ArrowLeft`. See USKeyboardLayout for a list of all key names.
   * @param options 
   */
  down(key: string, options?: KeyboardDownOptions): Promise<void>;

  /**
   * If `key` is a single character and no modifier keys besides `Shift` are being held down, a `keypress`/`input` event will also generated. The `text` option can be specified to force an input event to be generated.
   * 
   * **NOTE** Modifier keys DO effect `keyboard.press`. Holding down `Shift` will type the text in upper case.
   * 
   * Shortcut for `keyboard.down` and `keyboard.up`.
   * @param key Name of key to press, such as `ArrowLeft`. See USKeyboardLayout for a list of all key names.
   * @param options 
   */
  press(key: string, options?: KeyboardPressOptions): Promise<void>;

  /**
   * Dispatches a `keypress` and `input` event. This does not send a `keydown` or `keyup` event.
   * ```js
   * page.keyboard.sendCharacter('');
   * ```
   * 
   * **NOTE** Modifier keys DO NOT effect `keyboard.sendCharacter`. Holding down `Shift` will not type the text in upper case.
   * @param char Character to send into the page.
   */
  sendCharacter(char: string): Promise<void>;

  /**
   * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text.
   * To press a special key, like `Control` or `ArrowDown`, use `keyboard.press`.
   * ```js
   * page.keyboard.type('Hello'); // Types instantly
   * page.keyboard.type('World', {delay: 100}); // Types slower, like a user
   * ```
   * 
   * **NOTE** Modifier keys DO NOT effect `keyboard.type`. Holding down `Shift` will not type the text in upper case.
   * @param text A text to type into a focused element.
   * @param options 
   */
  type(text: string, options?: KeyboardTypeOptions): Promise<void>;

  /**
   * Dispatches a `keyup` event.
   * @param key Name of key to release, such as `ArrowLeft`. See USKeyboardLayout for a list of all key names.
   */
  up(key: string): Promise<void>;
}

/**
 * The Mouse class operates in main-frame CSS pixels relative to the top-left corner of the viewport.
 * Every `page` object has its own Mouse, accessible with `page.mouse`.
 * ```js
 * // Using page.mouse to trace a 100x100 square.
 * await page.mouse.move(0, 0);
 * await page.mouse.down();
 * await page.mouse.move(0, 100);
 * await page.mouse.move(100, 100);
 * await page.mouse.move(100, 0);
 * await page.mouse.move(0, 0);
 * await page.mouse.up();
 * ```
 */
export interface Mouse {
  /**
   * Shortcut for `mouse.move`, `mouse.down` and `mouse.up`.
   * @param x 
   * @param y 
   * @param options 
   */
  click(x: number, y: number, options?: MouseClickOptions): Promise<void>;

  /**
   * Dispatches a `mousedown` event.
   * @param options 
   */
  down(options?: MouseDownOptions): Promise<void>;

  /**
   * Dispatches a `mousemove` event.
   * @param x 
   * @param y 
   * @param options 
   */
  move(x: number, y: number, options?: MouseMoveOptions): Promise<void>;

  /**
   * Dispatches a `mouseup` event.
   * @param options 
   */
  up(options?: MouseUpOptions): Promise<void>;
}

export interface Touchscreen {
  /**
   * Dispatches a `touchstart` and `touchend` event.
   * @param x 
   * @param y 
   */
  tap(x: number, y: number): Promise<void>;
}

/**
 * You can use `tracing.start` and `tracing.stop` to create a trace file which can be opened in Chrome DevTools or timeline viewer.
 * ```js
 * await page.tracing.start({path: 'trace.json'});
 * await page.goto('https://www.google.com');
 * await page.tracing.stop();
 * ```
 */
export interface Tracing {
  /**
   * Only one trace can be active at a time per browser.
   * @param options 
   */
  start(options: TracingStartOptions): Promise<void>;

  /**
   * @returns Promise which resolves to buffer with trace data.
   */
  stop(): Promise<Buffer>;
}

/**
 * Dialog objects are dispatched by page via the 'dialog' event.
 * An example of using `Dialog` class:
 * ```js
 * const puppeteer = require('puppeteer');
 * 
 * puppeteer.launch().then(async browser => {
 *   const page = await browser.newPage();
 *   page.on('dialog', async dialog => {
 *     console.log(dialog.message());
 *     await dialog.dismiss();
 *     await browser.close();
 *   });
 *   page.evaluate(() => alert('1'));
 * });
 * ```
 */
export interface Dialog {
  /**
   * @param promptText A text to enter in prompt. Does not cause any effects if the dialog's `type` is not prompt.
   * @returns Promise which resolves when the dialog has been accepted.
   */
  accept(promptText?: string): Promise<void>;

  /**
   * @returns If dialog is prompt, returns default prompt value. Otherwise, returns empty string.
   */
  defaultValue(): string;

  /**
   * @returns Promise which resolves when the dialog has been dismissed.
   */
  dismiss(): Promise<void>;

  /**
   * @returns A message displayed in the dialog.
   */
  message(): string;

  /**
   * @returns Dialog's type, can be one of `alert`, `beforeunload`, `confirm` or `prompt`.
   */
  type(): string;
}

/**
 * ConsoleMessage objects are dispatched by page via the 'console' event.
 */
export interface ConsoleMessage {
  args(): Array<JSHandle>;

  text(): string;

  /**
   * One of the following values: `'log'`, `'debug'`, `'info'`, `'error'`, `'warning'`, `'dir'`, `'dirxml'`, `'table'`, `'trace'`, `'clear'`, `'startGroup'`, `'startGroupCollapsed'`, `'endGroup'`, `'assert'`, `'profile'`, `'profileEnd'`, `'count'`, `'timeEnd'`.
   */
  type(): string;
}

/**
 * At every point of time, page exposes its current frame tree via the page.mainFrame() and frame.childFrames() methods.
 * Frame object's lifecycle is controlled by three events, dispatched on the page object:
 * 
 * 'frameattached' - fired when the frame gets attached to the page. A Frame can be attached to the page only once.
 * 'framenavigated' - fired when the frame commits navigation to a different URL.
 * 'framedetached' - fired when the frame gets detached from the page.  A Frame can be detached from the page only once.
 * 
 * An example of dumping frame tree:
 * ```js
 * const puppeteer = require('puppeteer');
 * 
 * puppeteer.launch().then(async browser => {
 *   const page = await browser.newPage();
 *   await page.goto('https://www.google.com/chrome/browser/canary.html');
 *   dumpFrameTree(page.mainFrame(), '');
 *   await browser.close();
 * 
 *   function dumpFrameTree(frame, indent) {
 *     console.log(indent + frame.url());
 *     for (let child of frame.childFrames())
 *       dumpFrameTree(child, indent + '  ');
 *   }
 * });
 * ```
 * An example of getting text from an iframe element:
 * ```js
 *   const frame = page.frames().find(frame => frame.name() === 'myframe');
 *   const text = await frame.$eval('.selector', element => element.textContent);
 *   console.log(text);
 * ```
 */
export interface Frame {
  /**
   * The method queries frame for the selector. If there's no such element within the frame, the method will resolve to `null`.
   * @param selector A selector to query frame for
   * @returns Promise which resolves to ElementHandle pointing to the frame element.
   */
  $(selector: string): Promise<null|ElementHandle>;

  /**
   * The method runs `document.querySelectorAll` within the frame. If no elements match the selector, the return value resolves to `[]`.
   * @param selector A selector to query frame for
   * @returns Promise which resolves to ElementHandles pointing to the frame elements.
   */
  $$(selector: string): Promise<Array<ElementHandle>>;

  /**
   * This method runs `Array.from(document.querySelectorAll(selector))` within the frame and passes it as the first argument to `pageFunction`.
   * If `pageFunction` returns a Promise, then `frame.$$eval` would wait for the promise to resolve and return its value.
   * Examples:
   * ```js
   * const divsCounts = await frame.$$eval('div', divs => divs.length);
   * ```
   * @param selector A selector to query frame for
   * @param pageFunction Function to be evaluated in browser context
   * @param args Arguments to pass to `pageFunction`
   * @returns Promise which resolves to the return value of `pageFunction`
   */
  $$eval(selector: string, pageFunction: Function, ...args: Array<Serializable|JSHandle>): Promise<Serializable>;

  /**
   * This method runs `document.querySelector` within the frame and passes it as the first argument to `pageFunction`. If there's no element matching `selector`, the method throws an error.
   * If `pageFunction` returns a Promise, then `frame.$eval` would wait for the promise to resolve and return its value.
   * Examples:
   * ```js
   * const searchValue = await frame.$eval('#search', el => el.value);
   * const preloadHref = await frame.$eval('link[rel=preload]', el => el.href);
   * const html = await frame.$eval('.main-container', e => e.outerHTML);
   * ```
   * @param selector A selector to query frame for
   * @param pageFunction Function to be evaluated in browser context
   * @param args Arguments to pass to `pageFunction`
   * @returns Promise which resolves to the return value of `pageFunction`
   */
  $eval(selector: string, pageFunction: Function, ...args: Array<Serializable|JSHandle>): Promise<Serializable>;

  /**
   * The method evaluates the XPath expression.
   * @param expression Expression to evaluate.
   */
  $x(expression: string): Promise<Array<ElementHandle>>;

  /**
   * Adds a `<script>` tag into the page with the desired url or content.
   * @param options 
   * @returns which resolves to the added tag when the script's onload fires or when the script content was injected into frame.
   */
  addScriptTag(options: FrameAddScriptTagOptions): Promise<ElementHandle>;

  /**
   * Adds a `<link rel="stylesheet">` tag into the page with the desired url or a `<style type="text/css">` tag with the content.
   * @param options 
   * @returns which resolves to the added tag when the stylesheet's onload fires or when the CSS content was injected into frame.
   */
  addStyleTag(options: FrameAddStyleTagOptions): Promise<ElementHandle>;

  childFrames(): Array<Frame>;

  /**
   * This method fetches an element with `selector`, scrolls it into view if needed, and then uses page.mouse to click in the center of the element.
   * If there's no element matching `selector`, the method throws an error.
   * Bear in mind that if `click()` triggers a navigation event and there's a separate `page.waitForNavigation()` promise to be resolved, you may end up with a race condition that yields unexpected results. The correct pattern for click and wait for navigation is the following:
   * ```javascript
   * const [response] = await Promise.all([
   *   page.waitForNavigation(waitOptions),
   *   frame.click(selector, clickOptions),
   * ]);
   * ```
   * @param selector A selector to search for element to click. If there are multiple elements satisfying the selector, the first will be clicked.
   * @param options 
   * @returns Promise which resolves when the element matching `selector` is successfully clicked. The Promise will be rejected if there is no element matching `selector`.
   */
  click(selector: string, options?: FrameClickOptions): Promise<void>;

  /**
   * Gets the full HTML contents of the frame, including the doctype.
   */
  content(): Promise<string>;

  /**
   * If the function passed to the `frame.evaluate` returns a Promise, then `frame.evaluate` would wait for the promise to resolve and return its value.
   * If the function passed to the `frame.evaluate` returns a non-Serializable value, then `frame.evaluate` resolves to `undefined`.
   * ```js
   * const result = await frame.evaluate(() => {
   *   return Promise.resolve(8 * 7);
   * });
   * console.log(result); // prints "56"
   * ```
   * A string can also be passed in instead of a function.
   * ```js
   * console.log(await frame.evaluate('1 + 2')); // prints "3"
   * ```
   * ElementHandle instances can be passed as arguments to the `frame.evaluate`:
   * ```js
   * const bodyHandle = await frame.$('body');
   * const html = await frame.evaluate(body => body.innerHTML, bodyHandle);
   * await bodyHandle.dispose();
   * ```
   * @param pageFunction Function to be evaluated in browser context
   * @param args Arguments to pass to  `pageFunction`
   * @returns Promise which resolves to the return value of `pageFunction`
   */
  evaluate(pageFunction: Function|string, ...args: Array<Serializable|JSHandle>): Promise<Serializable>;

  /**
   * The only difference between `frame.evaluate` and `frame.evaluateHandle` is that `frame.evaluateHandle` returns in-page object (JSHandle).
   * If the function, passed to the `frame.evaluateHandle`, returns a Promise, then `frame.evaluateHandle` would wait for the promise to resolve and return its value.
   * ```js
   * const aWindowHandle = await frame.evaluateHandle(() => Promise.resolve(window));
   * aWindowHandle; // Handle for the window object.
   * ```
   * A string can also be passed in instead of a function.
   * ```js
   * const aHandle = await frame.evaluateHandle('document'); // Handle for the 'document'.
   * ```
   * JSHandle instances can be passed as arguments to the `frame.evaluateHandle`:
   * ```js
   * const aHandle = await frame.evaluateHandle(() => document.body);
   * const resultHandle = await frame.evaluateHandle(body => body.innerHTML, aHandle);
   * console.log(await resultHandle.jsonValue());
   * await resultHandle.dispose();
   * ```
   * @param pageFunction Function to be evaluated in the page context
   * @param args Arguments to pass to `pageFunction`
   * @returns Promise which resolves to the return value of `pageFunction` as in-page object (JSHandle)
   */
  evaluateHandle(pageFunction: Function|string, ...args: Array<Serializable|JSHandle>): Promise<JSHandle>;

  /**
   * Returns promise that resolves to the frame's default execution context.
   */
  executionContext(): Promise<ExecutionContext>;

  /**
   * This method fetches an element with `selector` and focuses it.
   * If there's no element matching `selector`, the method throws an error.
   * @param selector A selector of an element to focus. If there are multiple elements satisfying the selector, the first will be focused.
   * @returns Promise which resolves when the element matching `selector` is successfully focused. The promise will be rejected if there is no element matching `selector`.
   */
  focus(selector: string): Promise<void>;

  /**
   * The `frame.goto` will throw an error if:
   * 
   * there's an SSL error (e.g. in case of self-signed certificates).
   * target URL is invalid.
   * the `timeout` is exceeded during navigation.
   * the main resource failed to load.
   * 
   * 
   * **NOTE** `frame.goto` either throw or return a main resource response. The only exceptions are navigation to `about:blank` or navigation to the same URL with a different hash, which would succeed and return `null`.
   * 
   * 
   * **NOTE** Headless mode doesn't support navigation to a PDF document. See the upstream issue.
   * @param url URL to navigate frame to. The url should include scheme, e.g. `https://`.
   * @param options Navigation parameters which might have the following properties:
   * @returns Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect.
   */
  goto(url: string, options?: FrameGotoOptions): Promise<null|Response>;

  /**
   * This method fetches an element with `selector`, scrolls it into view if needed, and then uses page.mouse to hover over the center of the element.
   * If there's no element matching `selector`, the method throws an error.
   * @param selector A selector to search for element to hover. If there are multiple elements satisfying the selector, the first will be hovered.
   * @returns Promise which resolves when the element matching `selector` is successfully hovered. Promise gets rejected if there's no element matching `selector`.
   */
  hover(selector: string): Promise<void>;

  /**
   * Returns `true` if the frame has been detached, or `false` otherwise.
   */
  isDetached(): boolean;

  /**
   * Returns frame's name attribute as specified in the tag.
   * If the name is empty, returns the id attribute instead.
   * 
   * **NOTE** This value is calculated once when the frame is created, and will not update if the attribute is changed later.
   */
  name(): string;

  /**
   * @returns Parent frame, if any. Detached frames and main frames return `null`.
   */
  parentFrame(): null|Frame;

  /**
   * Triggers a `change` and `input` event once all the provided options have been selected.
   * If there's no `<select>` element matching `selector`, the method throws an error.
   * ```js
   * frame.select('select#colors', 'blue'); // single selection
   * frame.select('select#colors', 'red', 'green', 'blue'); // multiple selections
   * ```
   * @param selector A selector to query frame for
   * @param values Values of options to select. If the `<select>` has the `multiple` attribute, all values are considered, otherwise only the first one is taken into account.
   * @returns An array of option values that have been successfully selected.
   */
  select(selector: string, ...values: Array<string>): Promise<Array<string>>;

  /**
   * @param html HTML markup to assign to the page.
   * @param options Parameters which might have the following properties:
   */
  setContent(html: string, options?: FrameSetContentOptions): Promise<void>;

  /**
   * This method fetches an element with `selector`, scrolls it into view if needed, and then uses page.touchscreen to tap in the center of the element.
   * If there's no element matching `selector`, the method throws an error.
   * @param selector A selector to search for element to tap. If there are multiple elements satisfying the selector, the first will be tapped.
   */
  tap(selector: string): Promise<void>;

  /**
   * @returns The page's title.
   */
  title(): Promise<string>;

  /**
   * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text.
   * To press a special key, like `Control` or `ArrowDown`, use `keyboard.press`.
   * ```js
   * frame.type('#mytextarea', 'Hello'); // Types instantly
   * frame.type('#mytextarea', 'World', {delay: 100}); // Types slower, like a user
   * ```
   * @param selector A selector of an element to type into. If there are multiple elements satisfying the selector, the first will be used.
   * @param text A text to type into a focused element.
   * @param options 
   */
  type(selector: string, text: string, options?: FrameTypeOptions): Promise<void>;

  /**
   * Returns frame's url.
   */
  url(): string;

  /**
   * This method behaves differently with respect to the type of the first parameter:
   * 
   * if `selectorOrFunctionOrTimeout` is a `string`, then the first argument is treated as a selector or xpath, depending on whether or not it starts with '//', and the method is a shortcut for
   * frame.waitForSelector or frame.waitForXPath
   * if `selectorOrFunctionOrTimeout` is a `function`, then the first argument is treated as a predicate to wait for and the method is a shortcut for frame.waitForFunction().
   * if `selectorOrFunctionOrTimeout` is a `number`, then the first argument is treated as a timeout in milliseconds and the method returns a promise which resolves after the timeout
   * otherwise, an exception is thrown
   * 
   * ```js
   * // wait for selector
   * await page.waitFor('.foo');
   * // wait for 1 second
   * await page.waitFor(1000);
   * // wait for predicate
   * await page.waitFor(() => !!document.querySelector('.foo'));
   * ```
   * To pass arguments from node.js to the predicate of `page.waitFor` function:
   * ```js
   * const selector = '.foo';
   * await page.waitFor(selector => !!document.querySelector(selector), {}, selector);
   * ```
   * @param selectorOrFunctionOrTimeout A selector, predicate or timeout to wait for
   * @param options Optional waiting parameters
   * @param args Arguments to pass to  `pageFunction`
   * @returns Promise which resolves to a JSHandle of the success value
   */
  waitFor(selectorOrFunctionOrTimeout: string|number|Function, options?: Object, ...args: Array<Serializable|JSHandle>): Promise<JSHandle>;

  /**
   * The `waitForFunction` can be used to observe viewport size change:
   * ```js
   * const puppeteer = require('puppeteer');
   * 
   * puppeteer.launch().then(async browser => {
   *   const page = await browser.newPage();
   *   const watchDog = page.mainFrame().waitForFunction('window.innerWidth < 100');
   *   page.setViewport({width: 50, height: 50});
   *   await watchDog;
   *   await browser.close();
   * });
   * ```
   * To pass arguments from node.js to the predicate of `page.waitForFunction` function:
   * ```js
   * const selector = '.foo';
   * await page.waitForFunction(selector => !!document.querySelector(selector), {}, selector);
   * ```
   * @param pageFunction Function to be evaluated in browser context
   * @param options Optional waiting parameters
   * @param args Arguments to pass to  `pageFunction`
   * @returns Promise which resolves when the `pageFunction` returns a truthy value. It resolves to a JSHandle of the truthy value.
   */
  waitForFunction(pageFunction: Function|string, options?: FrameWaitForFunctionOptions, ...args: Array<Serializable|JSHandle>): Promise<JSHandle>;

  /**
   * This resolves when the frame navigates to a new URL. It is useful for when you run code
   * which will indirectly cause the frame to navigate. Consider this example:
   * ```js
   * const [response] = await Promise.all([
   *   frame.waitForNavigation(), // The navigation promise resolves after navigation has finished
   *   frame.click('a.my-link'), // Clicking the link will indirectly cause a navigation
   * ]);
   * ```
   * **NOTE** Usage of the History API to change the URL is considered a navigation.
   * @param options Navigation parameters which might have the following properties:
   * @returns Promise which resolves to the main resource response. In case of multiple redirects, the navigation will resolve with the response of the last redirect. In case of navigation to a different anchor or navigation due to History API usage, the navigation will resolve with `null`.
   */
  waitForNavigation(options?: FrameWaitForNavigationOptions): Promise<null|Response>;

  /**
   * Wait for the `selector` to appear in page. If at the moment of calling
   * the method the `selector` already exists, the method will return
   * immediately. If the selector doesn't appear after the `timeout` milliseconds of waiting, the function will throw.
   * This method works across navigations:
   * ```js
   * const puppeteer = require('puppeteer');
   * 
   * puppeteer.launch().then(async browser => {
   *   const page = await browser.newPage();
   *   let currentURL;
   *   page.mainFrame()
   *     .waitForSelector('img')
   *     .then(() => console.log('First URL with image: ' + currentURL));
   *   for (currentURL of ['https://example.com', 'https://google.com', 'https://bbc.com'])
   *     await page.goto(currentURL);
   *   await browser.close();
   * });
   * ```
   * @param selector A selector of an element to wait for
   * @param options Optional waiting parameters
   * @returns Promise which resolves when element specified by selector string is added to DOM.
   */
  waitForSelector(selector: string, options?: FrameWaitForSelectorOptions): Promise<ElementHandle>;

  /**
   * Wait for the `xpath` to appear in page. If at the moment of calling
   * the method the `xpath` already exists, the method will return
   * immediately. If the xpath doesn't appear after the `timeout` milliseconds of waiting, the function will throw.
   * This method works across navigations:
   * ```js
   * const puppeteer = require('puppeteer');
   * 
   * puppeteer.launch().then(async browser => {
   *   const page = await browser.newPage();
   *   let currentURL;
   *   page.mainFrame()
   *     .waitForXPath('//img')
   *     .then(() => console.log('First URL with image: ' + currentURL));
   *   for (currentURL of ['https://example.com', 'https://google.com', 'https://bbc.com'])
   *     await page.goto(currentURL);
   *   await browser.close();
   * });
   * ```
   * @param xpath A xpath of an element to wait for
   * @param options Optional waiting parameters
   * @returns Promise which resolves when element specified by xpath string is added to DOM.
   */
  waitForXPath(xpath: string, options?: FrameWaitForXPathOptions): Promise<ElementHandle>;
}

/**
 * The class represents a context for JavaScript execution. A Page might have many execution contexts:
 * 
 * each frame has "default" execution context that is
 * always created after frame is attached to DOM. This context is returned by the `frame.executionContext()` method.
 * Extensions's content scripts create additional execution contexts.
 * 
 * Besides pages, execution contexts can be found in workers.
 */
export interface ExecutionContext {
  /**
   * If the function passed to the `executionContext.evaluate` returns a Promise, then `executionContext.evaluate` would wait for the promise to resolve and return its value.
   * ```js
   * const executionContext = await page.mainFrame().executionContext();
   * const result = await executionContext.evaluate(() => Promise.resolve(8 * 7));
   * console.log(result); // prints "56"
   * ```
   * A string can also be passed in instead of a function.
   * ```js
   * console.log(await executionContext.evaluate('1 + 2')); // prints "3"
   * ```
   * JSHandle instances can be passed as arguments to the `executionContext.evaluate`:
   * ```js
   * const oneHandle = await executionContext.evaluateHandle(() => 1);
   * const twoHandle = await executionContext.evaluateHandle(() => 2);
   * const result = await executionContext.evaluate((a, b) => a + b, oneHandle, twoHandle);
   * await oneHandle.dispose();
   * await twoHandle.dispose();
   * console.log(result); // prints '3'.
   * ```
   * @param pageFunction Function to be evaluated in `executionContext`
   * @param args Arguments to pass to `pageFunction`
   * @returns Promise which resolves to the return value of `pageFunction`
   */
  evaluate(pageFunction: Function|string, ...args: Array<Serializable|JSHandle>): Promise<Serializable>;

  /**
   * The only difference between `executionContext.evaluate` and `executionContext.evaluateHandle` is that `executionContext.evaluateHandle` returns in-page object (JSHandle).
   * If the function passed to the `executionContext.evaluateHandle` returns a Promise, then `executionContext.evaluateHandle` would wait for the promise to resolve and return its value.
   * ```js
   * const context = await page.mainFrame().executionContext();
   * const aHandle = await context.evaluateHandle(() => Promise.resolve(self));
   * aHandle; // Handle for the global object.
   * ```
   * A string can also be passed in instead of a function.
   * ```js
   * const aHandle = await context.evaluateHandle('1 + 2'); // Handle for the '3' object.
   * ```
   * JSHandle instances can be passed as arguments to the `executionContext.evaluateHandle`:
   * ```js
   * const aHandle = await context.evaluateHandle(() => document.body);
   * const resultHandle = await context.evaluateHandle(body => body.innerHTML, aHandle);
   * console.log(await resultHandle.jsonValue()); // prints body's innerHTML
   * await aHandle.dispose();
   * await resultHandle.dispose();
   * ```
   * @param pageFunction Function to be evaluated in the `executionContext`
   * @param args Arguments to pass to `pageFunction`
   * @returns Promise which resolves to the return value of `pageFunction` as in-page object (JSHandle)
   */
  evaluateHandle(pageFunction: Function|string, ...args: Array<Serializable|JSHandle>): Promise<JSHandle>;

  /**
   * **NOTE** Not every execution context is associated with a frame. For example, workers and extensions have execution contexts that are not associated with frames.
   * @returns Frame associated with this execution context.
   */
  frame(): null|Frame;

  /**
   * The method iterates the JavaScript heap and finds all the objects with the given prototype.
   * ```js
   * // Create a Map object
   * await page.evaluate(() => window.map = new Map());
   * // Get a handle to the Map object prototype
   * const mapPrototype = await page.evaluateHandle(() => Map.prototype);
   * // Query all map instances into an array
   * const mapInstances = await page.queryObjects(mapPrototype);
   * // Count amount of map objects in heap
   * const count = await page.evaluate(maps => maps.length, mapInstances);
   * await mapInstances.dispose();
   * await mapPrototype.dispose();
   * ```
   * @param prototypeHandle A handle to the object prototype.
   * @returns A handle to an array of objects with this prototype
   */
  queryObjects(prototypeHandle: JSHandle): Promise<JSHandle>;
}

/**
 * JSHandle represents an in-page JavaScript object. JSHandles can be created with the page.evaluateHandle method.
 * ```js
 * const windowHandle = await page.evaluateHandle(() => window);
 * // ...
 * ```
 * JSHandle prevents the referenced JavaScript object being garbage collected unless the handle is disposed. JSHandles are auto-disposed when their origin frame gets navigated or the parent context gets destroyed.
 * JSHandle instances can be used as arguments in `page.$eval()`, `page.evaluate()` and `page.evaluateHandle` methods.
 */
export interface JSHandle {
  /**
   * Returns either `null` or the object handle itself, if the object handle is an instance of ElementHandle.
   */
  asElement(): null|ElementHandle;

  /**
   * The `jsHandle.dispose` method stops referencing the element handle.
   * @returns Promise which resolves when the object handle is successfully disposed.
   */
  dispose(): Promise<void>;

  /**
   * Returns execution context the handle belongs to.
   */
  executionContext(): ExecutionContext;

  /**
   * The method returns a map with property names as keys and JSHandle instances for the property values.
   * ```js
   * const handle = await page.evaluateHandle(() => ({window, document}));
   * const properties = await handle.getProperties();
   * const windowHandle = properties.get('window');
   * const documentHandle = properties.get('document');
   * await handle.dispose();
   * ```
   */
  getProperties(): Promise<Map<string, JSHandle>>;

  /**
   * Fetches a single property from the referenced object.
   * @param propertyName property to get
   */
  getProperty(propertyName: string): Promise<JSHandle>;

  /**
   * Returns a JSON representation of the object. If the object has a
   * `toJSON`
   * function, it **will not be called**.
   * 
   * **NOTE** The method will return an empty JSON object if the referenced object is not stringifiable. It will throw an error if the object has circular references.
   */
  jsonValue(): Promise<Object>;
}

/**
 * ElementHandle represents an in-page DOM element. ElementHandles can be created with the page.$ method.
 * ```js
 * const puppeteer = require('puppeteer');
 * 
 * puppeteer.launch().then(async browser => {
 *   const page = await browser.newPage();
 *   await page.goto('https://google.com');
 *   const inputElement = await page.$('input[type=submit]');
 *   await inputElement.click();
 *   // ...
 * });
 * ```
 * ElementHandle prevents DOM element from garbage collection unless the handle is disposed. ElementHandles are auto-disposed when their origin frame gets navigated.
 * ElementHandle instances can be used as arguments in `page.$eval()` and `page.evaluate()` methods.
 */
export interface ElementHandle extends JSHandle {
  /**
   * The method runs `element.querySelector` within the page. If no element matches the selector, the return value resolves to `null`.
   * @param selector A selector to query element for
   */
  $(selector: string): Promise<null|ElementHandle>;

  /**
   * The method runs `element.querySelectorAll` within the page. If no elements match the selector, the return value resolves to `[]`.
   * @param selector A selector to query element for
   */
  $$(selector: string): Promise<Array<ElementHandle>>;

  /**
   * This method runs `document.querySelectorAll` within the element and passes it as the first argument to `pageFunction`. If there's no element matching `selector`, the method throws an error.
   * If `pageFunction` returns a Promise, then `frame.$$eval` would wait for the promise to resolve and return its value.
   * Examples:
   * ```html
   * <div class="feed">
   *   <div class="tweet">Hello!</div>
   *   <div class="tweet">Hi!</div>
   * </div>
   * ```
   * ```js
   * const feedHandle = await page.$('.feed');
   * expect(await feedHandle.$$eval('.tweet', nodes => nodes.map(n => n.innerText))).toEqual(['Hello!', 'Hi!']);
   * ```
   * @param selector A selector to query page for
   * @param pageFunction Function to be evaluated in browser context
   * @param args Arguments to pass to `pageFunction`
   * @returns Promise which resolves to the return value of `pageFunction`
   */
  $$eval(selector: string, pageFunction: Function, ...args: Array<Serializable|JSHandle>): Promise<Serializable>;

  /**
   * This method runs `document.querySelector` within the element and passes it as the first argument to `pageFunction`. If there's no element matching `selector`, the method throws an error.
   * If `pageFunction` returns a Promise, then `frame.$eval` would wait for the promise to resolve and return its value.
   * Examples:
   * ```js
   * const tweetHandle = await page.$('.tweet');
   * expect(await tweetHandle.$eval('.like', node => node.innerText)).toBe('100');
   * expect(await tweetHandle.$eval('.retweets', node => node.innerText)).toBe('10');
   * ```
   * @param selector A selector to query page for
   * @param pageFunction Function to be evaluated in browser context
   * @param args Arguments to pass to `pageFunction`
   * @returns Promise which resolves to the return value of `pageFunction`
   */
  $eval(selector: string, pageFunction: Function, ...args: Array<Serializable|JSHandle>): Promise<Serializable>;

  /**
   * The method evaluates the XPath expression relative to the elementHandle. If there are no such elements, the method will resolve to an empty array.
   * @param expression Expression to evaluate.
   */
  $x(expression: string): Promise<Array<ElementHandle>>;

  asElement(): ElementHandle;

  /**
   * This method returns the bounding box of the element (relative to the main frame), or `null` if the element is not visible.
   */
  boundingBox(): Promise<null|ElementHandleBoundingBox>;

  /**
   * This method returns boxes of the element, or `null` if the element is not visible. Boxes are represented as an array of points; each Point is an object `{x, y}`. Box points are sorted clock-wise.
   */
  boxModel(): Promise<null|ElementHandleBoxModel>;

  /**
   * This method scrolls element into view if needed, and then uses page.mouse to click in the center of the element.
   * If the element is detached from DOM, the method throws an error.
   * @param options 
   * @returns Promise which resolves when the element is successfully clicked. Promise gets rejected if the element is detached from DOM.
   */
  click(options?: ElementHandleClickOptions): Promise<void>;

  /**
   * @returns Resolves to the content frame for element handles referencing iframe nodes, or null otherwise
   */
  contentFrame(): Promise<null|Frame>;

  /**
   * The `elementHandle.dispose` method stops referencing the element handle.
   * @returns Promise which resolves when the element handle is successfully disposed.
   */
  dispose(): Promise<void>;

  executionContext(): ExecutionContext;

  /**
   * Calls focus on the element.
   */
  focus(): Promise<void>;

  /**
   * The method returns a map with property names as keys and JSHandle instances for the property values.
   * ```js
   * const listHandle = await page.evaluateHandle(() => document.body.children);
   * const properties = await listHandle.getProperties();
   * const children = [];
   * for (const property of properties.values()) {
   *   const element = property.asElement();
   *   if (element)
   *     children.push(element);
   * }
   * children; // holds elementHandles to all children of document.body
   * ```
   */
  getProperties(): Promise<Map<string, JSHandle>>;

  /**
   * Fetches a single property from the objectHandle.
   * @param propertyName property to get
   */
  getProperty(propertyName: string): Promise<JSHandle>;

  /**
   * This method scrolls element into view if needed, and then uses page.mouse to hover over the center of the element.
   * If the element is detached from DOM, the method throws an error.
   * @returns Promise which resolves when the element is successfully hovered.
   */
  hover(): Promise<void>;

  /**
   * @returns Resolves to true if the element is visible in the current viewport.
   */
  isIntersectingViewport(): Promise<boolean>;

  /**
   * Returns a JSON representation of the object. The JSON is generated by running `JSON.stringify` on the object in page and consequent `JSON.parse` in puppeteer.
   * 
   * **NOTE** The method will throw if the referenced object is not stringifiable.
   */
  jsonValue(): Promise<Object>;

  /**
   * Focuses the element, and then uses `keyboard.down` and `keyboard.up`.
   * If `key` is a single character and no modifier keys besides `Shift` are being held down, a `keypress`/`input` event will also be generated. The `text` option can be specified to force an input event to be generated.
   * 
   * **NOTE** Modifier keys DO effect `elementHandle.press`. Holding down `Shift` will type the text in upper case.
   * @param key Name of key to press, such as `ArrowLeft`. See USKeyboardLayout for a list of all key names.
   * @param options 
   */
  press(key: string, options?: ElementHandlePressOptions): Promise<void>;

  /**
   * This method scrolls element into view if needed, and then uses page.screenshot to take a screenshot of the element.
   * If the element is detached from DOM, the method throws an error.
   * @param options Same options as in page.screenshot.
   * @returns Promise which resolves to buffer or a base64 string (depending on the value of `options.encoding`) with captured screenshot.
   */
  screenshot(options?: Object): Promise<string|Buffer>;

  /**
   * This method scrolls element into view if needed, and then uses touchscreen.tap to tap in the center of the element.
   * If the element is detached from DOM, the method throws an error.
   * @returns Promise which resolves when the element is successfully tapped. Promise gets rejected if the element is detached from DOM.
   */
  tap(): Promise<void>;

  toString(): string;

  /**
   * Focuses the element, and then sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text.
   * To press a special key, like `Control` or `ArrowDown`, use `elementHandle.press`.
   * ```js
   * elementHandle.type('Hello'); // Types instantly
   * elementHandle.type('World', {delay: 100}); // Types slower, like a user
   * ```
   * An example of typing into a text field and then submitting the form:
   * ```js
   * const elementHandle = await page.$('input');
   * await elementHandle.type('some text');
   * await elementHandle.press('Enter');
   * ```
   * @param text A text to type into a focused element.
   * @param options 
   */
  type(text: string, options?: ElementHandleTypeOptions): Promise<void>;

  /**
   * This method expects `elementHandle` to point to an input element.
   * @param filePaths Sets the value of the file input these paths. If some of the  `filePaths` are relative paths, then they are resolved relative to current working directory.
   */
  uploadFile(...filePaths: Array<string>): Promise<void>;
}

/**
 * Whenever the page sends a request, such as for a network resource, the following events are emitted by puppeteer's page:
 * 
 * 'request' emitted when the request is issued by the page.
 * 'response' emitted when/if the response is received for the request.
 * 'requestfinished' emitted when the response body is downloaded and the request is complete.
 * 
 * If request fails at some point, then instead of 'requestfinished' event (and possibly instead of 'response' event), the  'requestfailed' event is emitted.
 * If request gets a 'redirect' response, the request is successfully finished with the 'requestfinished' event, and a new request is  issued to a redirected url.
 */
export interface Request {
  /**
   * Aborts request. To use this, request interception should be enabled with `page.setRequestInterception`.
   * Exception is immediately thrown if the request interception is not enabled.
   * @param errorCode Optional error code. Defaults to `failed`, could be one of the following:
   */
  abort(errorCode?: string): Promise<void>;

  /**
   * Continues request with optional request overrides. To use this, request interception should be enabled with `page.setRequestInterception`.
   * Exception is immediately thrown if the request interception is not enabled.
   * ```js
   * await page.setRequestInterception(true);
   * page.on('request', request => {
   *   // Override headers
   *   const headers = Object.assign({}, request.headers(), {
   *     foo: 'bar', // set "foo" header
   *     origin: undefined, // remove "origin" header
   *   });
   *   request.continue({headers});
   * });
   * ```
   * @param overrides Optional request overwrites, which can be one of the following:
   */
  continue(overrides?: RequestContinueOptions): Promise<void>;

  /**
   * The method returns `null` unless this request was failed, as reported by
   * `requestfailed` event.
   * Example of logging all failed requests:
   * ```js
   * page.on('requestfailed', request => {
   *   console.log(request.url() + ' ' + request.failure().errorText);
   * });
   * ```
   * @returns Object describing request failure, if any
   */
  failure(): null|RequestFailure;

  /**
   * @returns A Frame that initiated this request, or `null` if navigating to error pages.
   */
  frame(): null|Frame;

  /**
   * @returns An object with HTTP headers associated with the request. All header names are lower-case.
   */
  headers(): Object;

  /**
   * Whether this request is driving frame's navigation.
   */
  isNavigationRequest(): boolean;

  /**
   * @returns Request's method (GET, POST, etc.)
   */
  method(): string;

  /**
   * @returns Request's post body, if any.
   */
  postData(): string;

  /**
   * A `redirectChain` is a chain of requests initiated to fetch a resource.
   * 
   * If there are no redirects and the request was successful, the chain will be empty.
   * If a server responds with at least a single redirect, then the chain will
   * contain all the requests that were redirected.
   * 
   * `redirectChain` is shared between all the requests of the same chain.
   * For example, if the website `http://example.com` has a single redirect to
   * `https://example.com`, then the chain will contain one request:
   * ```js
   * const response = await page.goto('http://example.com');
   * const chain = response.request().redirectChain();
   * console.log(chain.length); // 1
   * console.log(chain[0].url()); // 'http://example.com'
   * ```
   * If the website `https://google.com` has no redirects, then the chain will be empty:
   * ```js
   * const response = await page.goto('https://google.com');
   * const chain = response.request().redirectChain();
   * console.log(chain.length); // 0
   * ```
   */
  redirectChain(): Array<Request>;

  /**
   * Contains the request's resource type as it was perceived by the rendering engine.
   * ResourceType will be one of the following: `document`, `stylesheet`, `image`, `media`, `font`, `script`, `texttrack`, `xhr`, `fetch`, `eventsource`, `websocket`, `manifest`, `other`.
   */
  resourceType(): string;

  /**
   * Fulfills request with given response. To use this, request interception should
   * be enabled with `page.setRequestInterception`. Exception is thrown if
   * request interception is not enabled.
   * An example of fulfilling all requests with 404 responses:
   * ```js
   * await page.setRequestInterception(true);
   * page.on('request', request => {
   *   request.respond({
   *     status: 404,
   *     contentType: 'text/plain',
   *     body: 'Not Found!'
   *   });
   * });
   * ```
   * 
   * **NOTE** Mocking responses for dataURL requests is not supported.
   * Calling `request.respond` for a dataURL request is a noop.
   * @param response Response that will fulfill this request
   */
  respond(response: RequestRespondOptions): Promise<void>;

  /**
   * @returns A matching Response object, or `null` if the response has not been received yet.
   */
  response(): null|Response;

  /**
   * @returns URL of the request.
   */
  url(): string;
}

/**
 * Response class represents responses which are received by page.
 */
export interface Response {
  /**
   * @returns Promise which resolves to a buffer with response body.
   */
  buffer(): Promise<Buffer>;

  /**
   * @returns A Frame that initiated this response, or `null` if navigating to error pages.
   */
  frame(): null|Frame;

  /**
   * True if the response was served from either the browser's disk cache or memory cache.
   */
  fromCache(): boolean;

  /**
   * True if the response was served by a service worker.
   */
  fromServiceWorker(): boolean;

  /**
   * @returns An object with HTTP headers associated with the response. All header names are lower-case.
   */
  headers(): Object;

  /**
   * This method will throw if the response body is not parsable via `JSON.parse`.
   * @returns Promise which resolves to a JSON representation of response body.
   */
  json(): Promise<Object>;

  /**
   * Contains a boolean stating whether the response was successful (status in the range 200-299) or not.
   */
  ok(): boolean;

  remoteAddress(): ResponseRemoteAddress;

  /**
   * @returns A matching Request object.
   */
  request(): Request;

  /**
   * @returns Security details if the response was received over the secure connection, or `null` otherwise.
   */
  securityDetails(): null|SecurityDetails;

  /**
   * Contains the status code of the response (e.g., 200 for a success).
   */
  status(): number;

  /**
   * Contains the status text of the response (e.g. usually an "OK" for a success).
   */
  statusText(): string;

  /**
   * @returns Promise which resolves to a text representation of response body.
   */
  text(): Promise<string>;

  /**
   * Contains the URL of the response.
   */
  url(): string;
}

/**
 * SecurityDetails class represents the security details when response was received over the secure connection.
 */
export interface SecurityDetails {
  /**
   * @returns A string with the name of issuer of the certificate.
   */
  issuer(): string;

  /**
   * @returns String with the security protocol, eg. "TLS 1.2".
   */
  protocol(): string;

  /**
   * @returns Name of the subject to which the certificate was issued to.
   */
  subjectName(): string;

  /**
   * @returns UnixTime stating the start of validity of the certificate.
   */
  validFrom(): number;

  /**
   * @returns UnixTime stating the end of validity of the certificate.
   */
  validTo(): number;
}

export interface Target {
  /**
   * Get the browser the target belongs to.
   */
  browser(): Browser;

  /**
   * The browser context the target belongs to.
   */
  browserContext(): BrowserContext;

  /**
   * Creates a Chrome Devtools Protocol session attached to the target.
   */
  createCDPSession(): Promise<CDPSession>;

  /**
   * Get the target that opened this target. Top-level targets return `null`.
   */
  opener(): null|Target;

  /**
   * If the target is not of type `"page"` or `"background_page"`, returns `null`.
   */
  page(): Promise<null|Page>;

  /**
   * Identifies what kind of target this is. Can be `"page"`, `"background_page"`, `"service_worker"`, `"browser"` or `"other"`.
   */
  type(): "page"|"background_page"|"service_worker"|"other"|"browser";

  url(): string;
}

/**
 * The `CDPSession` instances are used to talk raw Chrome Devtools Protocol:
 * 
 * protocol methods can be called with `session.send` method.
 * protocol events can be subscribed to with `session.on` method.
 * 
 * Documentation on DevTools Protocol can be found here: DevTools Protocol Viewer.
 * ```js
 * const client = await page.target().createCDPSession();
 * await client.send('Animation.enable');
 * client.on('Animation.animationCreated', () => console.log('Animation created!'));
 * const response = await client.send('Animation.getPlaybackRate');
 * console.log('playback rate is ' + response.playbackRate);
 * await client.send('Animation.setPlaybackRate', {
 *   playbackRate: response.playbackRate / 2
 * });
 * ```
 */
export interface CDPSession extends EventEmitter {
  /**
   * Detaches the cdpSession from the target. Once detached, the cdpSession object won't emit any events and can't be used
   * to send messages.
   */
  detach(): Promise<void>;

  /**
   * @param method protocol method name
   * @param params Optional method parameters
   */
  send(method: string, params?: Object): Promise<Object>;
}

/**
 * Coverage gathers information about parts of JavaScript and CSS that were used by the page.
 * An example of using JavaScript and CSS coverage to get percentage of initially
 * executed code:
 * ```js
 * // Enable both JavaScript and CSS coverage
 * await Promise.all([
 *   page.coverage.startJSCoverage(),
 *   page.coverage.startCSSCoverage()
 * ]);
 * // Navigate to page
 * await page.goto('https://example.com');
 * // Disable both JavaScript and CSS coverage
 * const [jsCoverage, cssCoverage] = await Promise.all([
 *   page.coverage.stopJSCoverage(),
 *   page.coverage.stopCSSCoverage(),
 * ]);
 * let totalBytes = 0;
 * let usedBytes = 0;
 * const coverage = [...jsCoverage, ...cssCoverage];
 * for (const entry of coverage) {
 *   totalBytes += entry.text.length;
 *   for (const range of entry.ranges)
 *     usedBytes += range.end - range.start - 1;
 * }
 * console.log(`Bytes used: ${usedBytes / totalBytes * 100}%`);
 * ```
 * To output coverage in a form consumable by Istanbul,
 * see puppeteer-to-istanbul.
 */
export interface Coverage {
  /**
   * @param options Set of configurable options for coverage
   * @returns Promise that resolves when coverage is started
   */
  startCSSCoverage(options?: CoverageStartCSSCoverageOptions): Promise<void>;

  /**
   * **NOTE** Anonymous scripts are ones that don't have an associated url. These are scripts that are dynamically created on the page using `eval` or `new Function`. If `reportAnonymousScripts` is set to `true`, anonymous scripts will have `__puppeteer_evaluation_script__` as their URL.
   * @param options Set of configurable options for coverage
   * @returns Promise that resolves when coverage is started
   */
  startJSCoverage(options?: CoverageStartJSCoverageOptions): Promise<void>;

  /**
   * **NOTE** CSS Coverage doesn't include dynamically injected style tags without sourceURLs.
   * @returns Promise that resolves to the array of coverage reports for all stylesheets
   */
  stopCSSCoverage(): Promise<Array<CoverageStopCSSCoverage>>;

  /**
   * **NOTE** JavaScript Coverage doesn't include anonymous scripts by default. However, scripts with sourceURLs are
   * reported.
   * @returns Promise that resolves to the array of coverage reports for all scripts
   */
  stopJSCoverage(): Promise<Array<CoverageStopJSCoverage>>;
}

/**
 * TimeoutError is emitted whenever certain operations are terminated due to timeout, e.g. page.waitForSelector(selector[, options]) or puppeteer.launch([options]).
 */
export interface TimeoutError extends Error {

}

interface CoverageStopJSCoverage {
  /**
   * Script URL
   */
  url?: string;

  /**
   * Script content
   */
  text?: string;

  /**
   * Script ranges that were executed. Ranges are sorted and non-overlapping.
   */
  ranges?: Array<CoverageStopJSCoverageRanges>;
}

interface CoverageStopJSCoverageRanges {
  /**
   * A start offset in text, inclusive
   */
  start?: number;

  /**
   * An end offset in text, exclusive
   */
  end?: number;
}

interface CoverageStopCSSCoverage {
  /**
   * StyleSheet URL
   */
  url?: string;

  /**
   * StyleSheet content
   */
  text?: string;

  /**
   * StyleSheet ranges that were used. Ranges are sorted and non-overlapping.
   */
  ranges?: Array<CoverageStopCSSCoverageRanges>;
}

interface CoverageStopCSSCoverageRanges {
  /**
   * A start offset in text, inclusive
   */
  start?: number;

  /**
   * An end offset in text, exclusive
   */
  end?: number;
}

interface CoverageStartJSCoverageOptions {
  /**
   * Whether to reset coverage on every navigation. Defaults to `true`.
   */
  resetOnNavigation?: boolean;

  /**
   * Whether anonymous scripts generated by the page should be reported. Defaults to `false`.
   */
  reportAnonymousScripts?: boolean;
}

interface CoverageStartCSSCoverageOptions {
  /**
   * Whether to reset coverage on every navigation. Defaults to `true`.
   */
  resetOnNavigation?: boolean;
}

interface ResponseRemoteAddress {
  /**
   * the IP address of the remote server
   */
  ip?: string;

  /**
   * the port used to connect to the remote server
   */
  port?: number;
}

interface RequestRespondOptions {
  /**
   * Response status code, defaults to `200`.
   */
  status?: number;

  /**
   * Optional response headers
   */
  headers?: Object;

  /**
   * If set, equals to setting `Content-Type` response header
   */
  contentType?: string;

  /**
   * Optional response body
   */
  body?: string|Buffer;
}

interface RequestFailure {
  /**
   * Human-readable error message, e.g. `'net::ERR_FAILED'`.
   */
  errorText?: string;
}

interface RequestContinueOptions {
  /**
   * If set, the request url will be changed
   */
  url?: string;

  /**
   * If set changes the request method (e.g. `GET` or `POST`)
   */
  method?: string;

  /**
   * If set changes the post data of request
   */
  postData?: string;

  /**
   * If set changes the request HTTP headers
   */
  headers?: Object;
}

interface ElementHandleTypeOptions {
  /**
   * Time to wait between key presses in milliseconds. Defaults to 0.
   */
  delay?: number;
}

interface ElementHandlePressOptions {
  /**
   * If specified, generates an input event with this text.
   */
  text?: string;

  /**
   * Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.
   */
  delay?: number;
}

interface ElementHandleClickOptions {
  /**
   * Defaults to `left`.
   */
  button?: "left"|"right"|"middle";

  /**
   * defaults to 1. See UIEvent.detail.
   */
  clickCount?: number;

  /**
   * Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
   */
  delay?: number;
}

interface ElementHandleBoxModel {
  /**
   * Content box.
   */
  content?: Array<ElementHandleBoxModelContent>;

  /**
   * Padding box.
   */
  padding?: Array<ElementHandleBoxModelPadding>;

  /**
   * Border box.
   */
  border?: Array<ElementHandleBoxModelBorder>;

  /**
   * Margin box.
   */
  margin?: Array<ElementHandleBoxModelMargin>;

  /**
   * Element's width.
   */
  width?: number;

  /**
   * Element's height.
   */
  height?: number;
}

interface ElementHandleBoxModelMargin {
  x?: number;

  y?: number;
}

interface ElementHandleBoxModelBorder {
  x?: number;

  y?: number;
}

interface ElementHandleBoxModelPadding {
  x?: number;

  y?: number;
}

interface ElementHandleBoxModelContent {
  x?: number;

  y?: number;
}

interface ElementHandleBoundingBox {
  /**
   * the x coordinate of the element in pixels.
   */
  x?: number;

  /**
   * the y coordinate of the element in pixels.
   */
  y?: number;

  /**
   * the width of the element in pixels.
   */
  width?: number;

  /**
   * the height of the element in pixels.
   */
  height?: number;
}

interface FrameWaitForXPathOptions {
  /**
   * wait for element to be present in DOM and to be visible, i.e. to not have `display: none` or `visibility: hidden` CSS properties. Defaults to `false`.
   */
  visible?: boolean;

  /**
   * wait for element to not be found in the DOM or to be hidden, i.e. have `display: none` or `visibility: hidden` CSS properties. Defaults to `false`.
   */
  hidden?: boolean;

  /**
   * maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout.
   */
  timeout?: number;
}

interface FrameWaitForSelectorOptions {
  /**
   * wait for element to be present in DOM and to be visible, i.e. to not have `display: none` or `visibility: hidden` CSS properties. Defaults to `false`.
   */
  visible?: boolean;

  /**
   * wait for element to not be found in the DOM or to be hidden, i.e. have `display: none` or `visibility: hidden` CSS properties. Defaults to `false`.
   */
  hidden?: boolean;

  /**
   * maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout.
   */
  timeout?: number;
}

interface FrameWaitForNavigationOptions {
  /**
   * Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the page.setDefaultNavigationTimeout(timeout) method.
   */
  timeout?: number;

  /**
   * When to consider navigation succeeded, defaults to `load`. Given an array of event strings, navigation is considered to be successful after all events have been fired. Events can be either:
   */
  waitUntil?: string|Array<string>;
}

interface FrameWaitForFunctionOptions {
  /**
   * An interval at which the `pageFunction` is executed, defaults to `raf`. If `polling` is a number, then it is treated as an interval in milliseconds at which the function would be executed. If `polling` is a string, then it can be one of the following values:
   */
  polling?: string|number;

  /**
   * maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout.
   */
  timeout?: number;
}

interface FrameTypeOptions {
  /**
   * Time to wait between key presses in milliseconds. Defaults to 0.
   */
  delay?: number;
}

interface FrameSetContentOptions {
  /**
   * Maximum time in milliseconds for resources to load, defaults to 30 seconds, pass `0` to disable timeout.
   */
  timeout?: number;

  /**
   * When to consider setting markup succeeded, defaults to `load`. Given an array of event strings, setting content is considered to be successful after all events have been fired. Events can be either:
   */
  waitUntil?: string|Array<string>;
}

interface FrameGotoOptions {
  /**
   * Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the page.setDefaultNavigationTimeout(timeout) method.
   */
  timeout?: number;

  /**
   * When to consider navigation succeeded, defaults to `load`. Given an array of event strings, navigation is considered to be successful after all events have been fired. Events can be either:
   */
  waitUntil?: string|Array<string>;

  /**
   * Referer header value. If provided it will take preference over the referer header value set by page.setExtraHTTPHeaders().
   */
  referer?: string;
}

interface FrameClickOptions {
  /**
   * Defaults to `left`.
   */
  button?: "left"|"right"|"middle";

  /**
   * defaults to 1. See UIEvent.detail.
   */
  clickCount?: number;

  /**
   * Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
   */
  delay?: number;
}

interface FrameAddStyleTagOptions {
  /**
   * URL of the `<link>` tag.
   */
  url?: string;

  /**
   * Path to the CSS file to be injected into frame. If `path` is a relative path, then it is resolved relative to current working directory.
   */
  path?: string;

  /**
   * Raw CSS content to be injected into frame.
   */
  content?: string;
}

interface FrameAddScriptTagOptions {
  /**
   * URL of a script to be added.
   */
  url?: string;

  /**
   * Path to the JavaScript file to be injected into frame. If `path` is a relative path, then it is resolved relative to current working directory.
   */
  path?: string;

  /**
   * Raw JavaScript content to be injected into frame.
   */
  content?: string;

  /**
   * Script type. Use 'module' in order to load a Javascript ES6 module. See script for more details.
   */
  type?: string;
}

interface TracingStartOptions {
  /**
   * A path to write the trace file to.
   */
  path?: string;

  /**
   * captures screenshots in the trace.
   */
  screenshots?: boolean;

  /**
   * specify custom categories to use instead of default.
   */
  categories?: Array<string>;
}

interface MouseUpOptions {
  /**
   * Defaults to `left`.
   */
  button?: "left"|"right"|"middle";

  /**
   * defaults to 1. See UIEvent.detail.
   */
  clickCount?: number;
}

interface MouseMoveOptions {
  /**
   * defaults to 1. Sends intermediate `mousemove` events.
   */
  steps?: number;
}

interface MouseDownOptions {
  /**
   * Defaults to `left`.
   */
  button?: "left"|"right"|"middle";

  /**
   * defaults to 1. See UIEvent.detail.
   */
  clickCount?: number;
}

interface MouseClickOptions {
  /**
   * Defaults to `left`.
   */
  button?: "left"|"right"|"middle";

  /**
   * defaults to 1. See UIEvent.detail.
   */
  clickCount?: number;

  /**
   * Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
   */
  delay?: number;
}

interface KeyboardTypeOptions {
  /**
   * Time to wait between key presses in milliseconds. Defaults to 0.
   */
  delay?: number;
}

interface KeyboardPressOptions {
  /**
   * If specified, generates an input event with this text.
   */
  text?: string;

  /**
   * Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.
   */
  delay?: number;
}

interface KeyboardDownOptions {
  /**
   * If specified, generates an input event with this text.
   */
  text?: string;
}

interface AccessibilitySnapshot {
  /**
   * The role.
   */
  role?: string;

  /**
   * A human readable name for the node.
   */
  name?: string;

  /**
   * The current value of the node.
   */
  value?: string|number;

  /**
   * An additional human readable description of the node.
   */
  description?: string;

  /**
   * Keyboard shortcuts associated with this node.
   */
  keyshortcuts?: string;

  /**
   * A human readable alternative to the role.
   */
  roledescription?: string;

  /**
   * A description of the current value.
   */
  valuetext?: string;

  /**
   * Whether the node is disabled.
   */
  disabled?: boolean;

  /**
   * Whether the node is expanded or collapsed.
   */
  expanded?: boolean;

  /**
   * Whether the node is focused.
   */
  focused?: boolean;

  /**
   * Whether the node is modal.
   */
  modal?: boolean;

  /**
   * Whether the node text input supports multiline.
   */
  multiline?: boolean;

  /**
   * Whether more than one child can be selected.
   */
  multiselectable?: boolean;

  /**
   * Whether the node is read only.
   */
  readonly?: boolean;

  /**
   * Whether the node is required.
   */
  required?: boolean;

  /**
   * Whether the node is selected in its parent node.
   */
  selected?: boolean;

  /**
   * Whether the checkbox is checked, or "mixed".
   */
  checked?: boolean|"mixed";

  /**
   * Whether the toggle button is checked, or "mixed".
   */
  pressed?: boolean|"mixed";

  /**
   * The level of a heading.
   */
  level?: number;

  /**
   * The minimum value in a node.
   */
  valuemin?: number;

  /**
   * The maximum value in a node.
   */
  valuemax?: number;

  /**
   * What kind of autocomplete is supported by a control.
   */
  autocomplete?: string;

  /**
   * What kind of popup is currently being shown for a node.
   */
  haspopup?: string;

  /**
   * Whether and in what way this node's value is invalid.
   */
  invalid?: string;

  /**
   * Whether the node is oriented horizontally or vertically.
   */
  orientation?: string;

  /**
   * Child AXNodes of this node, if any.
   */
  children?: Array<Object>;
}

interface AccessibilitySnapshotOptions {
  /**
   * Prune uninteresting nodes from the tree. Defaults to `true`.
   */
  interestingOnly?: boolean;
}

interface PageWaitForXPathOptions {
  /**
   * wait for element to be present in DOM and to be visible, i.e. to not have `display: none` or `visibility: hidden` CSS properties. Defaults to `false`.
   */
  visible?: boolean;

  /**
   * wait for element to not be found in the DOM or to be hidden, i.e. have `display: none` or `visibility: hidden` CSS properties. Defaults to `false`.
   */
  hidden?: boolean;

  /**
   * maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout.
   */
  timeout?: number;
}

interface PageWaitForSelectorOptions {
  /**
   * wait for element to be present in DOM and to be visible, i.e. to not have `display: none` or `visibility: hidden` CSS properties. Defaults to `false`.
   */
  visible?: boolean;

  /**
   * wait for element to not be found in the DOM or to be hidden, i.e. have `display: none` or `visibility: hidden` CSS properties. Defaults to `false`.
   */
  hidden?: boolean;

  /**
   * maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout.
   */
  timeout?: number;
}

interface PageWaitForResponseOptions {
  /**
   * Maximum wait time in milliseconds, defaults to 30 seconds, pass `0` to disable the timeout.
   */
  timeout?: number;
}

interface PageWaitForRequestOptions {
  /**
   * Maximum wait time in milliseconds, defaults to 30 seconds, pass `0` to disable the timeout.
   */
  timeout?: number;
}

interface PageWaitForNavigationOptions {
  /**
   * Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the page.setDefaultNavigationTimeout(timeout) method.
   */
  timeout?: number;

  /**
   * When to consider navigation succeeded, defaults to `load`. Given an array of event strings, navigation is considered to be successful after all events have been fired. Events can be either:
   */
  waitUntil?: string|Array<string>;
}

interface PageWaitForFunctionOptions {
  /**
   * An interval at which the `pageFunction` is executed, defaults to `raf`. If `polling` is a number, then it is treated as an interval in milliseconds at which the function would be executed. If `polling` is a string, then it can be one of the following values:
   */
  polling?: string|number;

  /**
   * maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout.
   */
  timeout?: number;
}

interface PageViewport {
  /**
   * page width in pixels.
   */
  width?: number;

  /**
   * page height in pixels.
   */
  height?: number;

  /**
   * Specify device scale factor (can be though of as dpr). Defaults to `1`.
   */
  deviceScaleFactor?: number;

  /**
   * Whether the `meta viewport` tag is taken into account. Defaults to `false`.
   */
  isMobile?: boolean;

  /**
   * Specifies if viewport supports touch events. Defaults to `false`
   */
  hasTouch?: boolean;

  /**
   * Specifies if viewport is in landscape mode. Defaults to `false`.
   */
  isLandscape?: boolean;
}

interface PageTypeOptions {
  /**
   * Time to wait between key presses in milliseconds. Defaults to 0.
   */
  delay?: number;
}

interface PageSetViewportOptions {
  /**
   * page width in pixels. **required**
   */
  width?: number;

  /**
   * page height in pixels. **required**
   */
  height?: number;

  /**
   * Specify device scale factor (can be thought of as dpr). Defaults to `1`.
   */
  deviceScaleFactor?: number;

  /**
   * Whether the `meta viewport` tag is taken into account. Defaults to `false`.
   */
  isMobile?: boolean;

  /**
   * Specifies if viewport supports touch events. Defaults to `false`
   */
  hasTouch?: boolean;

  /**
   * Specifies if viewport is in landscape mode. Defaults to `false`.
   */
  isLandscape?: boolean;
}

interface PageSetGeolocationOptions {
  /**
   * Latitude between -90 and 90.
   */
  latitude?: number;

  /**
   * Longitude between -180 and 180.
   */
  longitude?: number;

  /**
   * Optional non-negative accuracy value.
   */
  accuracy?: number;
}

interface PageSetCookieOptions {
  /**
   * **required**
   */
  name?: string;

  /**
   * **required**
   */
  value?: string;

  url?: string;

  domain?: string;

  path?: string;

  /**
   * Unix time in seconds.
   */
  expires?: number;

  httpOnly?: boolean;

  secure?: boolean;

  sameSite?: "Strict"|"Lax";
}

interface PageSetContentOptions {
  /**
   * Maximum time in milliseconds for resources to load, defaults to 30 seconds, pass `0` to disable timeout.
   */
  timeout?: number;

  /**
   * When to consider setting markup succeeded, defaults to `load`. Given an array of event strings, setting content is considered to be successful after all events have been fired. Events can be either:
   */
  waitUntil?: string|Array<string>;
}

interface PageScreenshotOptions {
  /**
   * The file path to save the image to. The screenshot type will be inferred from file extension. If `path` is a relative path, then it is resolved relative to current working directory. If no path is provided, the image won't be saved to the disk.
   */
  path?: string;

  /**
   * Specify screenshot type, can be either `jpeg` or `png`. Defaults to 'png'.
   */
  type?: string;

  /**
   * The quality of the image, between 0-100. Not applicable to `png` images.
   */
  quality?: number;

  /**
   * When true, takes a screenshot of the full scrollable page. Defaults to `false`.
   */
  fullPage?: boolean;

  /**
   * An object which specifies clipping region of the page. Should have the following fields:
   */
  clip?: PageScreenshotOptionsClip;

  /**
   * Hides default white background and allows capturing screenshots with transparency. Defaults to `false`.
   */
  omitBackground?: boolean;

  /**
   * The encoding of the image, can be either `base64` or `binary`. Defaults to `binary`.
   */
  encoding?: string;
}

interface PageScreenshotOptionsClip {
  /**
   * x-coordinate of top-left corner of clip area
   */
  x?: number;

  /**
   * y-coordinate of top-left corner of clip area
   */
  y?: number;

  /**
   * width of clipping area
   */
  width?: number;

  /**
   * height of clipping area
   */
  height?: number;
}

interface PageReloadOptions {
  /**
   * Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the page.setDefaultNavigationTimeout(timeout) method.
   */
  timeout?: number;

  /**
   * When to consider navigation succeeded, defaults to `load`. Given an array of event strings, navigation is considered to be successful after all events have been fired. Events can be either:
   */
  waitUntil?: string|Array<string>;
}

interface PagePdfOptions {
  /**
   * The file path to save the PDF to. If `path` is a relative path, then it is resolved relative to current working directory. If no path is provided, the PDF won't be saved to the disk.
   */
  path?: string;

  /**
   * Scale of the webpage rendering. Defaults to `1`. Scale amount must be between 0.1 and 2.
   */
  scale?: number;

  /**
   * Display header and footer. Defaults to `false`.
   */
  displayHeaderFooter?: boolean;

  /**
   * HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values into them:
   */
  headerTemplate?: string;

  /**
   * HTML template for the print footer. Should use the same format as the `headerTemplate`.
   */
  footerTemplate?: string;

  /**
   * Print background graphics. Defaults to `false`.
   */
  printBackground?: boolean;

  /**
   * Paper orientation. Defaults to `false`.
   */
  landscape?: boolean;

  /**
   * Paper ranges to print, e.g., '1-5, 8, 11-13'. Defaults to the empty string, which means print all pages.
   */
  pageRanges?: string;

  /**
   * Paper format. If set, takes priority over `width` or `height` options. Defaults to 'Letter'.
   */
  format?: string;

  /**
   * Paper width, accepts values labeled with units.
   */
  width?: string|number;

  /**
   * Paper height, accepts values labeled with units.
   */
  height?: string|number;

  /**
   * Paper margins, defaults to none.
   */
  margin?: PagePdfOptionsMargin;

  /**
   * Give any CSS `@page` size declared in the page priority over what is declared in `width` and `height` or `format` options. Defaults to `false`, which will scale the content to fit the paper size.
   */
  preferCSSPageSize?: boolean;
}

interface PagePdfOptionsMargin {
  /**
   * Top margin, accepts values labeled with units.
   */
  top?: string|number;

  /**
   * Right margin, accepts values labeled with units.
   */
  right?: string|number;

  /**
   * Bottom margin, accepts values labeled with units.
   */
  bottom?: string|number;

  /**
   * Left margin, accepts values labeled with units.
   */
  left?: string|number;
}

interface PageMetrics {
  /**
   * The timestamp when the metrics sample was taken.
   */
  Timestamp?: number;

  /**
   * Number of documents in the page.
   */
  Documents?: number;

  /**
   * Number of frames in the page.
   */
  Frames?: number;

  /**
   * Number of events in the page.
   */
  JSEventListeners?: number;

  /**
   * Number of DOM nodes in the page.
   */
  Nodes?: number;

  /**
   * Total number of full or partial page layout.
   */
  LayoutCount?: number;

  /**
   * Total number of page style recalculations.
   */
  RecalcStyleCount?: number;

  /**
   * Combined durations of all page layouts.
   */
  LayoutDuration?: number;

  /**
   * Combined duration of all page style recalculations.
   */
  RecalcStyleDuration?: number;

  /**
   * Combined duration of JavaScript execution.
   */
  ScriptDuration?: number;

  /**
   * Combined duration of all tasks performed by the browser.
   */
  TaskDuration?: number;

  /**
   * Used JavaScript heap size.
   */
  JSHeapUsedSize?: number;

  /**
   * Total JavaScript heap size.
   */
  JSHeapTotalSize?: number;
}

interface PageGotoOptions {
  /**
   * Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the page.setDefaultNavigationTimeout(timeout) method.
   */
  timeout?: number;

  /**
   * When to consider navigation succeeded, defaults to `load`. Given an array of event strings, navigation is considered to be successful after all events have been fired. Events can be either:
   */
  waitUntil?: string|Array<string>;

  /**
   * Referer header value. If provided it will take preference over the referer header value set by page.setExtraHTTPHeaders().
   */
  referer?: string;
}

interface PageGoForwardOptions {
  /**
   * Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the page.setDefaultNavigationTimeout(timeout) method.
   */
  timeout?: number;

  /**
   * When to consider navigation succeeded, defaults to `load`. Given an array of event strings, navigation is considered to be successful after all events have been fired. Events can be either:
   */
  waitUntil?: string|Array<string>;
}

interface PageGoBackOptions {
  /**
   * Maximum navigation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by using the page.setDefaultNavigationTimeout(timeout) method.
   */
  timeout?: number;

  /**
   * When to consider navigation succeeded, defaults to `load`. Given an array of event strings, navigation is considered to be successful after all events have been fired. Events can be either:
   */
  waitUntil?: string|Array<string>;
}

interface PageEmulateOptions {
  viewport?: PageEmulateOptionsViewport;

  userAgent?: string;
}

interface PageEmulateOptionsViewport {
  /**
   * page width in pixels.
   */
  width?: number;

  /**
   * page height in pixels.
   */
  height?: number;

  /**
   * Specify device scale factor (can be thought of as dpr). Defaults to `1`.
   */
  deviceScaleFactor?: number;

  /**
   * Whether the `meta viewport` tag is taken into account. Defaults to `false`.
   */
  isMobile?: boolean;

  /**
   * Specifies if viewport supports touch events. Defaults to `false`
   */
  hasTouch?: boolean;

  /**
   * Specifies if viewport is in landscape mode. Defaults to `false`.
   */
  isLandscape?: boolean;
}

interface PageDeleteCookieOptions {
  /**
   * **required**
   */
  name?: string;

  url?: string;

  domain?: string;

  path?: string;
}

interface PageCookies {
  name?: string;

  value?: string;

  domain?: string;

  path?: string;

  /**
   * Unix time in seconds.
   */
  expires?: number;

  size?: number;

  httpOnly?: boolean;

  secure?: boolean;

  session?: boolean;

  sameSite?: "Strict"|"Lax";
}

interface PageCloseOptions {
  /**
   * Defaults to `false`. Whether to run the
   * before unload
   * page handlers.
   */
  runBeforeUnload?: boolean;
}

interface PageClickOptions {
  /**
   * Defaults to `left`.
   */
  button?: "left"|"right"|"middle";

  /**
   * defaults to 1. See UIEvent.detail.
   */
  clickCount?: number;

  /**
   * Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
   */
  delay?: number;
}

interface PageAuthenticateOptions {
  username?: string;

  password?: string;
}

interface PageAddStyleTagOptions {
  /**
   * URL of the `<link>` tag.
   */
  url?: string;

  /**
   * Path to the CSS file to be injected into frame. If `path` is a relative path, then it is resolved relative to current working directory.
   */
  path?: string;

  /**
   * Raw CSS content to be injected into frame.
   */
  content?: string;
}

interface PageAddScriptTagOptions {
  /**
   * URL of a script to be added.
   */
  url?: string;

  /**
   * Path to the JavaScript file to be injected into frame. If `path` is a relative path, then it is resolved relative to current working directory.
   */
  path?: string;

  /**
   * Raw JavaScript content to be injected into frame.
   */
  content?: string;

  /**
   * Script type. Use 'module' in order to load a Javascript ES6 module. See script for more details.
   */
  type?: string;
}

interface PageMetrics {
  /**
   * The title passed to `console.timeStamp`.
   */
  title?: string;

  /**
   * Object containing metrics as key/value pairs. The values
   * of metrics are of <number> type.
   */
  metrics?: Object;
}

interface PageMetricsPayload {
  /**
   * The title passed to `console.timeStamp`.
   */
  title?: string;

  /**
   * Object containing metrics as key/value pairs. The values
   * of metrics are of <number> type.
   */
  metrics?: Object;
}

interface PageMetricsPayload {
  /**
   * The title passed to `console.timeStamp`.
   */
  title?: string;

  /**
   * Object containing metrics as key/value pairs. The values
   * of metrics are of <number> type.
   */
  metrics?: Object;
}

interface PageMetricsPayload {
  /**
   * The title passed to `console.timeStamp`.
   */
  title?: string;

  /**
   * Object containing metrics as key/value pairs. The values
   * of metrics are of <number> type.
   */
  metrics?: Object;
}

interface BrowserContextWaitForTargetOptions {
  /**
   * Maximum wait time in milliseconds. Pass `0` to disable the timeout. Defaults to 30 seconds.
   */
  timeout?: number;
}

interface BrowserWaitForTargetOptions {
  /**
   * Maximum wait time in milliseconds. Pass `0` to disable the timeout. Defaults to 30 seconds.
   */
  timeout?: number;
}

interface BrowserFetcherRevisionInfo {
  /**
   * the revision the info was created from
   */
  revision?: string;

  /**
   * path to the extracted revision folder
   */
  folderPath?: string;

  /**
   * path to the revision executable
   */
  executablePath?: string;

  /**
   * URL this revision can be downloaded from
   */
  url?: string;

  /**
   * whether the revision is locally available on disk
   */
  local?: boolean;
}

interface BrowserFetcherDownload {
  /**
   * the revision the info was created from
   */
  revision?: string;

  /**
   * path to the extracted revision folder
   */
  folderPath?: string;

  /**
   * path to the revision executable
   */
  executablePath?: string;

  /**
   * URL this revision can be downloaded from
   */
  url?: string;

  /**
   * whether the revision is locally available on disk
   */
  local?: boolean;
}

interface LaunchOptions {
  /**
   * Whether to ignore HTTPS errors during navigation. Defaults to `false`.
   */
  ignoreHTTPSErrors?: boolean;

  /**
   * Whether to run browser in headless mode. Defaults to `true` unless the `devtools` option is `true`.
   */
  headless?: boolean;

  /**
   * Path to a Chromium or Chrome executable to run instead of the bundled Chromium. If `executablePath` is a relative path, then it is resolved relative to current working directory. **BEWARE**: Puppeteer is only guaranteed to work with the bundled Chromium, use at your own risk.
   */
  executablePath?: string;

  /**
   * Slows down Puppeteer operations by the specified amount of milliseconds. Useful so that you can see what is going on.
   */
  slowMo?: number;

  /**
   * Sets a consistent viewport for each page. Defaults to an 800x600 viewport. `null` disables the default viewport.
   */
  defaultViewport?: null|LaunchOptionsDefaultViewport;

  /**
   * Additional arguments to pass to the browser instance. The list of Chromium flags can be found here.
   */
  args?: Array<string>;

  /**
   * If `true`, then do not use `puppeteer.defaultArgs()`. If an array is given, then filter out the given default arguments. Dangerous option; use with care. Defaults to `false`.
   */
  ignoreDefaultArgs?: boolean|Array<string>;

  /**
   * Close the browser process on Ctrl-C. Defaults to `true`.
   */
  handleSIGINT?: boolean;

  /**
   * Close the browser process on SIGTERM. Defaults to `true`.
   */
  handleSIGTERM?: boolean;

  /**
   * Close the browser process on SIGHUP. Defaults to `true`.
   */
  handleSIGHUP?: boolean;

  /**
   * Maximum time in milliseconds to wait for the browser instance to start. Defaults to `30000` (30 seconds). Pass `0` to disable timeout.
   */
  timeout?: number;

  /**
   * Whether to pipe the browser process stdout and stderr into `process.stdout` and `process.stderr`. Defaults to `false`.
   */
  dumpio?: boolean;

  /**
   * Path to a User Data Directory.
   */
  userDataDir?: string;

  /**
   * Specify environment variables that will be visible to the browser. Defaults to `process.env`.
   */
  env?: Object;

  /**
   * Whether to auto-open a DevTools panel for each tab. If this option is `true`, the `headless` option will be set `false`.
   */
  devtools?: boolean;

  /**
   * Connects to the browser over a pipe instead of a WebSocket. Defaults to `false`.
   */
  pipe?: boolean;
}

interface LaunchOptionsDefaultViewport {
  /**
   * page width in pixels.
   */
  width?: number;

  /**
   * page height in pixels.
   */
  height?: number;

  /**
   * Specify device scale factor (can be thought of as dpr). Defaults to `1`.
   */
  deviceScaleFactor?: number;

  /**
   * Whether the `meta viewport` tag is taken into account. Defaults to `false`.
   */
  isMobile?: boolean;

  /**
   * Specifies if viewport supports touch events. Defaults to `false`
   */
  hasTouch?: boolean;

  /**
   * Specifies if viewport is in landscape mode. Defaults to `false`.
   */
  isLandscape?: boolean;
}

interface DefaultArgsOptions {
  /**
   * Whether to run browser in headless mode. Defaults to `true` unless the `devtools` option is `true`.
   */
  headless?: boolean;

  /**
   * Additional arguments to pass to the browser instance. The list of Chromium flags can be found here.
   */
  args?: Array<string>;

  /**
   * Path to a User Data Directory.
   */
  userDataDir?: string;

  /**
   * Whether to auto-open a DevTools panel for each tab. If this option is `true`, the `headless` option will be set `false`.
   */
  devtools?: boolean;
}

interface CreateBrowserFetcherOptions {
  /**
   * A download host to be used. Defaults to `https://storage.googleapis.com`.
   */
  host?: string;

  /**
   * A path for the downloads folder. Defaults to `<root>/.local-chromium`, where `<root>` is puppeteer's package root.
   */
  path?: string;

  /**
   * Possible values are: `mac`, `win32`, `win64`, `linux`. Defaults to the current platform.
   */
  platform?: string;
}

interface ConnectOptions {
  /**
   * a browser websocket endpoint to connect to.
   */
  browserWSEndpoint?: string;

  /**
   * Whether to ignore HTTPS errors during navigation. Defaults to `false`.
   */
  ignoreHTTPSErrors?: boolean;

  /**
   * Sets a consistent viewport for each page. Defaults to an 800x600 viewport. `null` disables the default viewport.
   */
  defaultViewport?: null|ConnectOptionsDefaultViewport;

  /**
   * Slows down Puppeteer operations by the specified amount of milliseconds. Useful so that you can see what is going on.
   */
  slowMo?: number;

  /**
   * **Experimental** Specify a custom transport object for Puppeteer to use.
   */
  transport?: ConnectionTransport;
}

interface ConnectOptionsDefaultViewport {
  /**
   * page width in pixels.
   */
  width?: number;

  /**
   * page height in pixels.
   */
  height?: number;

  /**
   * Specify device scale factor (can be thought of as dpr). Defaults to `1`.
   */
  deviceScaleFactor?: number;

  /**
   * Whether the `meta viewport` tag is taken into account. Defaults to `false`.
   */
  isMobile?: boolean;

  /**
   * Specifies if viewport supports touch events. Defaults to `false`
   */
  hasTouch?: boolean;

  /**
   * Specifies if viewport is in landscape mode. Defaults to `false`.
   */
  isLandscape?: boolean;
}

